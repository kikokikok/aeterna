# Knowledge Provider Specification

## Purpose
OpenSpec defines a **universal protocol for Knowledge Providers** that enables AI agents, tools, and applications to seamlessly query, store, and retrieve knowledge from pluggable backend systems.

### Goals

1. **Universal Compatibility**: Any OpenCode-compliant agent can use any OpenSpec provider
2. **Pluggable Architecture**: Easy to add/remove knowledge sources
3. **Type Safety**: Strong typing for all operations
4. **Performance**: Efficient query and retrieval with minimal overhead
5. **Extensibility**: Rich capabilities for diverse knowledge sources

---

## Requirements

### Requirement: Knowledge Provider Interface
The system SHALL provide a backend that stores knowledge, supports queries, manages metadata, and exposes OpenSpec-compliant endpoints.

#### Scenario: Provider initialization
**WHEN** a knowledge provider is initialized
**THEN** the provider MUST be ready to accept knowledge entries
**AND** the provider MUST expose discovery endpoint for capability enumeration
**AND** the provider MUST support all required OpenSpec operations

### Requirement: Core Concepts
The system SHALL implement core knowledge provider concepts including knowledge entry model, source tracking, and access policies.

#### Scenario: Knowledge provider initialization
**WHEN** a knowledge provider is initialized
**THEN** the provider SHALL support storing knowledge entries
**AND** SHALL support querying knowledge with semantic or structured search
**AND** SHALL manage metadata, access policies, and versioning
**AND** SHALL expose a standardized OpenSpec API

A **Knowledge Provider** is a backend system that:
- **Stores** knowledge documents, facts, and embeddings
- **Queries** knowledge using semantic search or structured queries
- **Manages** metadata, access policies, and versioning
- **Exposes** a standardized OpenSpec API

### Knowledge Entry

```typescript
interface KnowledgeEntry {
  id: string;                    // Unique identifier
  content: string;                // Raw content (text, code, document)
  embedding?: number[];          // Vector representation (optional for some providers)
  metadata: KnowledgeMetadata;   // Structured metadata
  source: KnowledgeSource;        // Where knowledge came from
  access_policy: AccessPolicy;   // Who can access this entry
  created_at: ISO8601;          // Creation timestamp
  updated_at?: ISO8601;         // Last modification
  version?: number;              // Version number (for versioned knowledge)
}

interface KnowledgeMetadata {
  title?: string;
  description?: string;
  tags?: string[];
  language?: string;
  author?: string;
  confidence?: number;            // 0.0-1.0 confidence score
  importance?: number;           // 0.0-1.0 importance score
  custom?: Record<string, any>;  // Provider-specific metadata
}
```

### Knowledge Source

```typescript
enum KnowledgeSourceType {
  "user_upload",              // User uploaded documents
  "git_repository",         // Git repository
  "notebooklm",            // NotebookLM source
  "dust_ai",                // Dust.tt AI
  "perplexity",             // Perplexity AI
  "web_scrape",             // Web-scraped content
  "api_import",              // Imported from API
  "agent_generated",         // Generated by AI agent
  "custom_provider"          // Custom knowledge provider
}

interface KnowledgeSource {
  type: KnowledgeSourceType;
  identifier: string;          // URL, repo name, etc.
  version?: string;            // Git commit hash, API version, etc.
  provider_id?: string;       // Which knowledge provider
}
```

### Access Policy

```typescript
enum AccessPolicy {
  "private",          // Only creator can access
  "restricted",       // Creator + approved users
  "shared",          // Team/group can access
  "organization",    // Anyone in organization
  "public",          // Anyone (with auth)
}

interface AccessPolicyConfig {
  policy: AccessPolicy;
  approved_users?: string[];     // For "restricted"
  allowed_teams?: string[];      // For "shared"
}
```

### Requirement: Knowledge Entry Model
The system SHALL implement a KnowledgeEntry model with metadata, embeddings, source tracking, and access policies.

#### Scenario: Create knowledge entry
- **WHEN** a client creates a knowledge entry with content and metadata
- **THEN** the system SHALL generate a unique identifier
- **AND** SHALL store content, metadata, and source information
- **AND** SHALL optionally generate vector embeddings
- **AND** SHALL apply the specified access policy

### Requirement: Memory Layer Architecture
The system SHALL support a multi-layered memory hierarchy for optimal performance and data organization.

#### Scenario: Cross-layer query with ranking
- **WHEN** a query is submitted with multiple layer types specified
- **THEN** all specified layers are queried concurrently
- **AND** results are aggregated and ranked by relevance score
- **AND** total execution time includes all layer query times
- **AND** metadata reports which layers contributed results

---

### Layer Types

| Layer Type | Purpose | Storage | Performance |
|-------------|----------|----------|--------------|
| **working** | Temporary context (conversation state) | In-memory | ~µs latency |
| **session** | Session-specific data | Cache with TTL | ~ms latency |
| **episodic** | Agent experiences/events | Structured DB | ~10-50ms |
| **semantic** | Vector embeddings | Vector DB | ~20-100ms |
| **procedural** | Facts and rules | Structured DB | ~10-30ms |
| **user** | User personal memory | Structured DB + vectors | ~20-50ms |
| **organization** | Shared organizational knowledge | Structured DB + vectors | ~50-200ms |
| **archival** | Long-term storage | Vector DB secondary | ~100-500ms |

### Layer Characteristics

- **Working Memory**: Ultra-fast, ephemerally, in-memory
- **Session Memory**: Ephemeral, TTL-based, per-agent session
- **Episodic Memory**: Medium-term, timestamped events
- **Semantic Memory**: Long-term, vector search enabled
- **Procedural Memory**: Facts, rules, structured data
- **User Personal Memory**: User-specific knowledge with semantic search
- **Organization Memory**: Shared team knowledge with policies
- **Archival Memory**: Cold storage, bulk queries

### Cross-Layer Queries

Providers SHALL support concurrent queries across multiple layers with intelligent result aggregation:

#### Scenario: Cross-layer query with ranking
- **WHEN** a query is submitted with multiple layer types specified
- **THEN** all specified layers are queried concurrently
- **AND** results are aggregated and ranked by relevance score
- **AND** total execution time includes all layer query times
- **AND** metadata reports which layers contributed results

---

## OpenSpec Protocol Specification

### Requirement: Discovery Endpoint
The system SHALL provide a discovery endpoint for providers to expose capabilities and configuration.

**Endpoint**: `GET /openspec/v1/knowledge`

**Purpose**: Discover provider capabilities and configuration

**Request**:
```typescript
interface DiscoveryRequest {
  // No parameters required
}
```

**Response**:
```typescript
interface DiscoveryResponse {
  provider: {
    name: string;              // e.g., "Aeterna"
    version: string;           // e.g., "1.0.0"
    description: string;

    capabilities: {
      query: QueryCapabilities;
      storage: StorageCapabilities;
      metadata: MetadataCapabilities;
      streaming: StreamingCapabilities;
    };

    supported_sources: KnowledgeSourceType[];

    limits: {
      max_entry_size: number;      // bytes
      max_batch_size: number;       // entries
      max_embeddings_dim: number;    // dimensions
      query_rate_limit?: number;     // queries/minute
    };

    features: {
      semantic_search: boolean;      // Vector similarity
      hybrid_search: boolean;       // Semantic + keyword
      reranking: boolean;           // Result reranking
      cross_layer_query: boolean;  // Query multiple layers
      versioning: boolean;          // Knowledge versioning
      promotion: boolean;           // Auto-promote between layers
    };
  };
}
```

### Requirement: Query Endpoint
The system SHALL provide a query endpoint for searching and retrieving knowledge entries.

**Endpoint**: `POST /openspec/v1/knowledge/query`

**Purpose**: Search and retrieve knowledge entries

**Request**:
```typescript
interface QueryRequest {
  query: string;
  mode?: "semantic" | "keyword" | "hybrid";

  filters?: {
    source_type?: KnowledgeSourceType;
    access_policy?: AccessPolicy;
    created_after?: ISO8601;
    created_before?: ISO8601;
    tags?: string[];
    author?: string;
    custom_filters?: Record<string, any>;
  };

  options?: {
    limit?: number;                // Default: 10
    offset?: number;               // Default: 0
    distance_threshold?: number;    // Max distance for semantic search
    distance_metric?: "cosine" | "euclidean" | "dot";
    include_content?: boolean;    // Default: true
    include_embeddings?: boolean; // Default: false
    top_k?: number;              // For semantic search
  };

  layer?: {
    types?: ("working" | "session" | "episodic" | "semantic" |
            "procedural" | "user" | "organization" | "archival")[];
    agent_id?: string;             // For agent-specific queries
    user_id?: string;              // For user-specific queries
  };
}
```

**Response**:
```typescript
interface QueryResponse {
  query_id: string;
  results: QueryResult[];
  metadata: QueryMetadata;
  streaming_url?: string;        // If streaming enabled
}

interface QueryResult {
  entry: KnowledgeEntry;
  score: number;                 // Relevance score (0.0-1.0)
  distance?: number;             // For semantic search
  highlight?: {
    content: string[];          // Highlighted snippets
    metadata?: Record<string, string[]>;
  };
}

interface QueryMetadata {
  total_results: number;
  execution_time_ms: number;
  layers_queried: string[];    // Layers that were searched
  provider: {
    name: string;
    version: string;
  };
}
```

#### Scenario: Semantic search query
- **WHEN** a client submits a semantic query with mode="semantic"
- **THEN** provider performs vector similarity search
- **AND** results are ordered by similarity score
- **AND** distance metric is applied as specified (default: cosine)
- **AND** execution time is <200ms for semantic layer queries

#### Scenario: Cross-layer query
- **WHEN** a client specifies multiple layer types in layer.types
- **THEN** all specified layers are queried concurrently
- **AND** results from all layers are aggregated
- **AND** results are ranked by combined relevance score
- **AND** metadata includes all layers that were queried

### Requirement: Create/Update Endpoint
The system SHALL provide endpoints for creating and updating knowledge entries.

**Endpoint**: `POST /openspec/v1/knowledge/create`
**Endpoint**: `PUT /openspec/v1/knowledge/{id}`

**Purpose**: Store or update knowledge entries

**Request**:
```typescript
interface CreateRequest {
  entry: Omit<KnowledgeEntry, "id" | "created_at" | "updated_at">;

  options?: {
    generate_embedding?: boolean;  // Auto-generate embedding
    access_policy?: AccessPolicyConfig;
    version?: boolean;              // Enable versioning
    layer?: {                    // Target memory layer
      type: MemoryLayerType;
      agent_id?: string;
      user_id?: string;
    };
  };

  governance?: {
    require_approval?: boolean;   // Require human approval
    verification_required?: boolean;
    audit_log?: boolean;
  };
}
```

**Response**:
```typescript
interface CreateResponse {
  entry: KnowledgeEntry;
  status: "created" | "updated" | "pending_approval";

  approval_required?: {
    request_id: string;
    requested_by: string;
    requested_at: ISO8601;
  };
}
```

#### Scenario: Create entry with auto-embedding
- **WHEN** a client creates a knowledge entry with options.generate_embedding=true
- **THEN** provider generates vector embedding for the content
- **AND** stores both content and embedding
- **AND** returns the created entry with embedding populated
- **AND** generation completes within specified latency targets

### Requirement: Delete Endpoint
The system SHALL provide an endpoint for removing knowledge entries.

**Endpoint**: `DELETE /openspec/v1/knowledge/{id}`

**Purpose**: Remove knowledge entries

**Request**:
```typescript
interface DeleteRequest {
  id: string;

  options?: {
    hard_delete?: boolean;       // Remove all versions
    governance?: {
      require_approval?: boolean;
      reason?: string;           // Reason for deletion
    };
  };
}
```

**Response**:
```typescript
interface DeleteResponse {
  deleted: boolean;
  entry_id: string;

  approval_required?: {
    request_id: string;
    requested_by: string;
    requested_at: ISO8601;
  };
}
```

### Requirement: Batch Operations Endpoint
The system SHALL provide a batch operations endpoint for bulk create, update, and delete operations.

**Endpoint**: `POST /openspec/v1/knowledge/batch`

**Purpose**: Bulk operations (create, update, delete)

**Request**:
```typescript
interface BatchRequest {
  operation: "create" | "update" | "delete" | "upsert";
  entries: (CreateRequest | UpdateRequest | DeleteRequest)[];
  options?: {
    continue_on_error?: boolean;  // Don't stop on first error
    notify_on_completion?: boolean;
  };
}
```

**Response**:
```typescript
interface BatchResponse {
  operation_id: string;
  status: "pending" | "processing" | "completed" | "failed";

  results: {
    succeeded: number;
    failed: number;
    errors: BatchError[];
  };

  results_url?: string;    // Download link when completed
}
```

### Requirement: Streaming Endpoint
The system SHALL provide a streaming endpoint for real-time knowledge updates and query results.

**Endpoint**: `GET /openspec/v1/knowledge/stream`

**Purpose**: Stream real-time knowledge updates and query results

**Request**:
```typescript
interface StreamRequest {
  type: "query" | "updates" | "notifications";
  query?: QueryRequest;          // For query streaming
  filters?: UpdateFilters;       // For update streaming

  format?: "sse" | "websocket";
}
```

**Response (SSE)**:
```typescript
// Server-Sent Events format
event: KnowledgeUpdateEvent | QueryResultEvent | NotificationEvent

interface KnowledgeUpdateEvent {
  type: "created" | "updated" | "deleted";
  entry: KnowledgeEntry;
  timestamp: ISO8601;
}

interface QueryResultEvent {
  query_id: string;
  result: QueryResult;
  is_final: boolean;      // True if this is last result
}
```

#### Scenario: Stream knowledge updates
- **WHEN** a client establishes SSE connection to /stream with type="updates"
- **THEN** provider sends real-time events for all knowledge operations
- **AND** events include created, updated, deleted operations
- **AND** each event includes entry data and timestamp
- **AND** connection remains open until client disconnects

### Requirement: Metadata Operations Endpoint
The system SHALL provide an endpoint for retrieving metadata without retrieving full content.

**Endpoint**: `GET /openspec/v1/knowledge/{id}/metadata`

**Purpose**: Retrieve metadata without content

**Request**:
```typescript
interface MetadataRequest {
  id: string;
  include_custom?: boolean;   // Include custom metadata fields
}
```

**Response**:
```typescript
interface MetadataResponse {
  entry_id: string;
  metadata: KnowledgeMetadata;
  source: KnowledgeSource;
  version_history?: {
    version: number;
    created_at: ISO8601;
    created_by: string;
  }[];
}
```

---

## Security & Authentication

### Authentication Methods

#### Bearer Token Authentication

```typescript
interface AuthConfig {
  type: "bearer" | "api_key" | "oauth2";
  token: string;
  expires_at?: ISO8601;
}
```

#### Authorization

```typescript
interface AuthorizationConfig {
  policies: {
    read: AccessPolicy[];       // Who can read knowledge
    write: AccessPolicy[];      // Who can write knowledge
    delete: AccessPolicy[];     // Who can delete knowledge
  };

  roles: {
    admin: string[];           // Admin role IDs
    user: string[];            // Standard user role IDs
    agent: string[];            // Agent role IDs
  };

  rate_limits: {
    queries_per_minute: number;
    creates_per_minute: number;
    batch_size_limit: number;
  };
}
```

### Security Headers

```typescript
interface SecurityHeaders {
  "X-Request-ID": string;           // Unique request ID
  "X-Rate-Limit-Remaining": string;  // Remaining requests
  "X-Rate-Limit-Reset": string;       // Rate limit reset time
  "X-Provider-Version": string;         // Provider version
}
```

---

## Error Handling

### Error Codes

```typescript
enum ErrorCode {
  // Client Errors (4xx)
  INVALID_REQUEST = 400,
  UNAUTHORIZED = 401,
  FORBIDDEN = 403,
  NOT_FOUND = 404,
  CONFLICT = 409,
  RATE_LIMITED = 429,

  // Server Errors (5xx)
  INTERNAL_ERROR = 500,
  NOT_IMPLEMENTED = 501,
  SERVICE_UNAVAILABLE = 503,

  // Provider-Specific Errors
  EMBEDDING_FAILED = 1001,
  STORAGE_FAILED = 1002,
  QUERY_FAILED = 1003,
  BATCH_FAILED = 1004,
  GOVERNANCE_DENIED = 1005,
}

interface ErrorResponse {
  error: {
    code: ErrorCode;
    message: string;
    details?: any;
  };

  request_id: string;           // For debugging
  timestamp: ISO8601;
}
```

---

## Performance Requirements

### Latency Targets

| Operation | P50 | P95 | P99 | Notes |
|-----------|------|------|------|-------|
| **Query (working memory)** | 1ms | 5ms | 10ms | In-memory cache |
| **Query (session memory)** | 5ms | 20ms | 50ms | Cache with TTL |
| **Query (episodic memory)** | 20ms | 50ms | 100ms | Structured DB |
| **Query (semantic memory)** | 50ms | 100ms | 200ms | Vector DB |
| **Query (archival memory)** | 100ms | 200ms | 500ms | Cold storage |
| **Create entry** | 50ms | 100ms | 200ms | Includes embedding |
| **Update entry** | 20ms | 50ms | 100ms | Without embedding |
| **Delete entry** | 10ms | 30ms | 50ms | Soft delete |

### Throughput Targets

| Metric | Target | Measurement |
|---------|--------|-------------|
| **Queries per second** | > 100 QPS | Concurrent queries |
| **Creates per second** | > 50 CPS | Includes embedding |
| **Batch operations** | > 1000 ops/min | Bulk operations |
| **Streaming events** | > 1000 events/sec | SSE/WebSocket |

---

## Testing Requirements

### Test Coverage

| Component Type | Unit Test Target | Integration Target | Overall Target |
|----------------|-------------------|---------------------|----------------|
| **Business Logic** | 90%+ | 85%+ | 85%+ |
| **Data Models** | 95%+ | N/A | 95%+ |
| **API Endpoints** | 85%+ | 85%+ | 85%+ |
| **Database Layer** | 85%+ | 80%+ | 80%+ |
| **Vector DB Layer** | 85%+ | 80%+ | 80%+ |
| **Query Engine** | 90%+ | 85%+ | 85%+ |

### Testability

**Requirement**: All external dependencies MUST be behind trait abstractions to enable easy mocking and testing.

**Example**:
```rust
#[async_trait]
pub trait EmbeddingProvider: Send + Sync {
    async fn embed(&self, text: &str) -> Result<Vec<f32>, Error>;
    async fn embed_batch(&self, texts: Vec<&str>) -> Result<Vec<Vec<f32>>, Error>;
}
```

### Property-Based Testing

**Requirement**: All critical algorithms MUST be tested with property-based testing frameworks.

**Critical Algorithms**:
1. Promotion Score Calculation
2. Cross-Layer Query Result Ordering
3. Embedding Similarity Metrics
4. Confidence Aggregation
5. Conflict Resolution
6. Version Merging
7. Access Policy Evaluation
8. Search Result Ranking

### Mutation Testing

**Requirement**: Critical code paths MUST achieve 90%+ mutation score (90%+ mutants killed).

---

## OpenAPI Specification

All OpenSpec Knowledge Providers MUST provide an OpenAPI 3.0 specification documenting:
- All endpoints
- Request/response schemas
- Authentication methods
- Error responses
- Rate limits
- Examples

---

## Compliance Checklist

| Requirement | Status | Implementation Notes |
|-------------|--------|---------------------|
| **Discovery endpoint** | ✅ Required | `GET /openspec/v1/knowledge` |
| **Query endpoint** | ✅ Required | `POST /openspec/v1/knowledge/query` |
| **Create/Update endpoint** | ✅ Required | `POST /openspec/v1/knowledge/create` + `PUT /openspec/v1/knowledge/{id}` |
| **Delete endpoint** | ✅ Required | `DELETE /openspec/v1/knowledge/{id}` |
| **Batch operations** | ✅ Required | `POST /openspec/v1/knowledge/batch` |
| **Streaming endpoint** | ✅ Required | `GET /openspec/v1/knowledge/stream` |
| **Metadata operations** | ✅ Required | `GET /openspec/v1/knowledge/{id}/metadata` |
| **Authentication** | ✅ Required | Bearer token + OAuth2 |
| **Error handling** | ✅ Required | Full error code system |
| **Performance requirements** | ✅ Required | Latency targets, throughput targets |
| **Testing requirements** | ✅ Required | Unit, integration, performance tests |
| **OpenAPI spec** | ✅ Required | OpenAPI 3.0 specification |
| **Documentation** | ✅ Required | Complete API reference + examples |

---

*Knowledge Provider Specification v1.0.0*
*Last Updated: 2026-01-07*
*OpenSpec-Compliant*
