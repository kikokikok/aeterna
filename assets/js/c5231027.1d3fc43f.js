"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6092],{7159(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"cca/extension-guide","title":"CCA Extension Development Guide","description":"This guide explains how to create custom extensions for CCA (Confucius Code Agent) capabilities. Extensions enable you to customize agent behavior, add prompt enhancements, configure tools, and manage stateful interactions.","source":"@site/docs/cca/extension-guide.md","sourceDirName":"cca","slug":"/cca/extension-guide","permalink":"/aeterna/docs/cca/extension-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/kikokikok/aeterna/tree/main/website/docs/cca/extension-guide.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"CCA API Reference","permalink":"/aeterna/docs/cca/api-reference"},"next":{"title":"CCA Redis Schema Documentation","permalink":"/aeterna/docs/cca/redis-schema"}}');var i=t(4848),o=t(8453);const r={},a="CCA Extension Development Guide",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Extension Architecture",id:"extension-architecture",level:2},{value:"Execution Flow",id:"execution-flow",level:3},{value:"Core Components",id:"core-components",level:2},{value:"1. ExtensionCallback Trait",id:"1-extensioncallback-trait",level:3},{value:"2. ExtensionContext API",id:"2-extensioncontext-api",level:3},{value:"3. ExtensionRegistration",id:"3-extensionregistration",level:3},{value:"4. ExtensionRegistry",id:"4-extensionregistry",level:3},{value:"5. PromptWiring",id:"5-promptwiring",level:3},{value:"State Management",id:"state-management",level:2},{value:"State Limits",id:"state-limits",level:3},{value:"State Operations",id:"state-operations",level:3},{value:"State Persistence",id:"state-persistence",level:3},{value:"Complete Extension Example",id:"complete-extension-example",level:2},{value:"Scenario: Context-Aware Code Reviewer",id:"scenario-context-aware-code-reviewer",level:3},{value:"Extension Patterns",id:"extension-patterns",level:2},{value:"Pattern 1: Enrichment Extension",id:"pattern-1-enrichment-extension",level:3},{value:"Pattern 2: Validation Extension",id:"pattern-2-validation-extension",level:3},{value:"Pattern 3: Caching Extension",id:"pattern-3-caching-extension",level:3},{value:"Pattern 4: Stateful Conversation Tracker",id:"pattern-4-stateful-conversation-tracker",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Extensions Focused",id:"1-keep-extensions-focused",level:3},{value:"2. Handle State Gracefully",id:"2-handle-state-gracefully",level:3},{value:"3. Validate Inputs",id:"3-validate-inputs",level:3},{value:"4. Use Appropriate Priorities",id:"4-use-appropriate-priorities",level:3},{value:"5. Limit State Size",id:"5-limit-state-size",level:3},{value:"6. Handle Timeouts",id:"6-handle-timeouts",level:3},{value:"7. Test Thoroughly",id:"7-test-thoroughly",level:3},{value:"Debugging Extensions",id:"debugging-extensions",level:2},{value:"Enable Debug Logging",id:"enable-debug-logging",level:3},{value:"Inspect State",id:"inspect-state",level:3},{value:"Monitor Performance",id:"monitor-performance",level:3},{value:"Deployment",id:"deployment",level:2},{value:"OpenCode Plugin Integration",id:"opencode-plugin-integration",level:3},{value:"State Storage Configuration",id:"state-storage-configuration",level:3},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"cca-extension-development-guide",children:"CCA Extension Development Guide"})}),"\n",(0,i.jsx)(n.p,{children:"This guide explains how to create custom extensions for CCA (Confucius Code Agent) capabilities. Extensions enable you to customize agent behavior, add prompt enhancements, configure tools, and manage stateful interactions."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The CCA extension system provides typed callbacks with state management, allowing you to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Transform input messages before processing"}),"\n",(0,i.jsx)(n.li,{children:"Enrich context with custom data"}),"\n",(0,i.jsxs)(n.li,{children:["Process tagged content (e.g., ",(0,i.jsx)(n.code,{children:"@file"}),", ",(0,i.jsx)(n.code,{children:"@url"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Post-process LLM outputs"}),"\n",(0,i.jsx)(n.li,{children:"Maintain stateful context across agent interactions"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Extensions run ",(0,i.jsx)(n.strong,{children:"client-side"})," in the OpenCode Plugin, providing low-latency processing while accessing server-side tools via MCP."]}),"\n",(0,i.jsx)(n.h2,{id:"extension-architecture",children:"Extension Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"User Input\n    \u2502\n    \u25bc\nExtension Chain (Priority DESC)\n    \u2502\n    \u251c\u2500 Extension A (priority: 10) \u2192 on_input_messages()\n    \u2502\n    \u251c\u2500 Extension B (priority: 5)  \u2192 on_input_messages()\n    \u2502\n    \u2514\u2500 Extension C (priority: 1)  \u2192 on_input_messages()\n    \u2502\n    \u25bc\nAgent Processing (with modified messages)\n    \u2502\n    \u25bc\nLLM Output\n    \u2502\n    \u25bc\nExtension Chain (Priority DESC)\n    \u2502\n    \u251c\u2500 Extension A \u2192 on_llm_output()\n    \u2502\n    \u251c\u2500 Extension B \u2192 on_llm_output()\n    \u2502\n    \u2514\u2500 Extension C \u2192 on_llm_output()\n    \u2502\n    \u25bc\nUser sees final output\n"})}),"\n",(0,i.jsx)(n.p,{children:"Each extension in the chain can:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Read/write state via ",(0,i.jsx)(n.code,{children:"ExtensionContext"})]}),"\n",(0,i.jsxs)(n.li,{children:["Call Aeterna MCP tools via ",(0,i.jsx)(n.code,{children:"ctx.tool_registry"})]}),"\n",(0,i.jsx)(n.li,{children:"Transform data and pass to next extension"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,i.jsx)(n.h3,{id:"1-extensioncallback-trait",children:"1. ExtensionCallback Trait"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ExtensionCallback"})," trait defines four hook points:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use async_trait::async_trait;\nuse tools::extensions::{ExtensionCallback, ExtensionContext, ExtensionError, ExtensionMessage};\n\n#[async_trait]\npub trait ExtensionCallback: Send + Sync {\n    /// Called when input messages are received\n    async fn on_input_messages(\n        &self,\n        ctx: &mut ExtensionContext,\n        messages: Vec<ExtensionMessage>\n    ) -> Result<Vec<ExtensionMessage>, ExtensionError> {\n        Ok(messages)  // Default: pass through unchanged\n    }\n\n    /// Called for plain text processing\n    async fn on_plain_text(\n        &self,\n        ctx: &mut ExtensionContext,\n        text: String\n    ) -> Result<String, ExtensionError> {\n        Ok(text)  // Default: pass through unchanged\n    }\n\n    /// Called when a tagged element is encountered (e.g., @file, @url)\n    async fn on_tag(\n        &self,\n        ctx: &mut ExtensionContext,\n        tag: String,\n        content: String\n    ) -> Result<String, ExtensionError> {\n        Ok(content)  // Default: pass through unchanged\n    }\n\n    /// Called after LLM generates output\n    async fn on_llm_output(\n        &self,\n        ctx: &mut ExtensionContext,\n        output: String\n    ) -> Result<String, ExtensionError> {\n        Ok(output)  // Default: pass through unchanged\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-extensioncontext-api",children:"2. ExtensionContext API"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ExtensionContext"})," provides access to:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct ExtensionContext {\n    pub tenant_ctx: TenantContext,      // Multi-tenant context\n    pub session_id: String,             // Current session ID\n    pub extension_id: String,           // This extension's ID\n    pub tool_registry: Arc<ToolRegistry>, // Access to MCP tools\n    // Private fields...\n}\n\nimpl ExtensionContext {\n    /// Get typed state value\n    pub fn get_state<T: DeserializeOwned>(&self, key: &str) -> Result<Option<T>, ExtensionError>;\n\n    /// Set typed state value\n    pub fn set_state<T: Serialize>(&mut self, key: &str, value: T) -> Result<(), ExtensionError>;\n\n    /// Clear all state for this extension\n    pub fn clear_state(&mut self);\n\n    /// Get raw state map (advanced usage)\n    pub fn state(&self) -> &HashMap<String, Value>;\n\n    /// Replace entire state (advanced usage)\n    pub fn replace_state(&mut self, state: HashMap<String, Value>);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-extensionregistration",children:"3. ExtensionRegistration"}),"\n",(0,i.jsx)(n.p,{children:"Register an extension with configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct ExtensionRegistration {\n    pub id: String,                          // Unique identifier\n    pub callbacks: Arc<dyn ExtensionCallback>, // Callback implementation\n    pub prompt_additions: Vec<PromptAddition>, // Prompt enhancements\n    pub tool_config: ToolConfig,             // Tool behavior overrides\n    pub sequence_hints: Vec<ToolSequenceHint>, // Tool sequencing hints\n    pub priority: i32,                       // Execution priority (higher = earlier)\n    pub enabled: bool,                       // Enable/disable flag\n    pub state_config: ExtensionStateConfig,  // State management config\n}\n\nimpl ExtensionRegistration {\n    pub fn new(id: impl Into<String>, callbacks: Arc<dyn ExtensionCallback>) -> Self;\n    pub fn with_priority(mut self, priority: i32) -> Self;\n    pub fn with_prompt_additions(mut self, additions: Vec<PromptAddition>) -> Self;\n    pub fn with_tool_config(mut self, config: ToolConfig) -> Self;\n    pub fn with_sequence_hints(mut self, hints: Vec<ToolSequenceHint>) -> Self;\n    pub fn enabled(mut self, enabled: bool) -> Self;\n    pub fn with_state_config(mut self, config: ExtensionStateConfig) -> Self;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-extensionregistry",children:"4. ExtensionRegistry"}),"\n",(0,i.jsx)(n.p,{children:"Manage multiple extensions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct ExtensionRegistry {\n    // Private fields...\n}\n\nimpl ExtensionRegistry {\n    pub fn new() -> Self;\n\n    /// Register a new extension\n    pub fn register_extension(&mut self, registration: ExtensionRegistration) -> Result<(), ExtensionError>;\n\n    /// Enable or disable an extension\n    pub fn enable_extension(&mut self, id: &str, enabled: bool) -> Result<(), ExtensionError>;\n\n    /// Get extensions in priority order (DESC)\n    pub fn list_ordered(&self) -> Vec<ExtensionRegistration>;\n\n    /// Generate prompt wiring for all enabled extensions\n    pub fn prompt_wiring(&self) -> PromptWiring;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"5-promptwiring",children:"5. PromptWiring"}),"\n",(0,i.jsx)(n.p,{children:"Combine prompt additions and tool configurations from all extensions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'pub struct PromptWiring {\n    pub additions: Vec<PromptAddition>,      // Prompt text additions\n    pub tool_config: ToolConfig,             // Combined tool config\n    pub sequencing_hints: Vec<ToolSequenceHint>, // Tool sequencing\n}\n\npub struct PromptAddition {\n    pub role: String,      // "system", "user", "assistant"\n    pub content: String,   // Prompt text to add\n}\n\npub struct ToolConfig {\n    pub suggested_tools: Vec<String>,        // Tools to suggest\n    pub disabled_tools: Vec<String>,         // Tools to disable\n    pub overrides: HashMap<String, String>,  // Tool parameter overrides\n}\n\npub struct ToolSequenceHint {\n    pub when_tool: String,    // When this tool is used...\n    pub suggest_next: String, // ...suggest this tool next\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"state-management",children:"State Management"}),"\n",(0,i.jsx)(n.h3,{id:"state-limits",children:"State Limits"}),"\n",(0,i.jsx)(n.p,{children:"To prevent memory exhaustion, state is limited:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct ExtensionStateConfig {\n    pub max_state_size_bytes: usize,  // Default: 1MB\n    pub state_ttl_seconds: u64,       // Default: 3600 (1 hour)\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Size Limit"}),": Default 1MB per extension (configurable)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"TTL"}),": Default 1 hour (configurable)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Eviction"}),": LRU (Least Recently Used) when storage is full"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compression"}),": zstd compression for storage efficiency"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"state-operations",children:"State Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Set state\nctx.set_state("key", value)?;  // Enforces size limit\n\n// Get state\nlet value: Option<MyType> = ctx.get_state("key")?;\n\n// Clear state\nctx.clear_state();\n\n// Example: Track conversation count\nlet count: u32 = ctx.get_state("message_count")?.unwrap_or(0);\nctx.set_state("message_count", count + 1)?;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"state-persistence",children:"State Persistence"}),"\n",(0,i.jsx)(n.p,{children:"State is persisted to Redis with compression:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"After each callback, state is serialized to JSON"}),"\n",(0,i.jsx)(n.li,{children:"Compressed with zstd"}),"\n",(0,i.jsxs)(n.li,{children:["Stored in Redis with key: ",(0,i.jsx)(n.code,{children:"ext:state:{session_id}:{extension_id}"})]}),"\n",(0,i.jsxs)(n.li,{children:["TTL applied based on ",(0,i.jsx)(n.code,{children:"state_ttl_seconds"})]}),"\n",(0,i.jsx)(n.li,{children:"Before next callback, state is loaded and decompressed"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"complete-extension-example",children:"Complete Extension Example"}),"\n",(0,i.jsx)(n.h3,{id:"scenario-context-aware-code-reviewer",children:"Scenario: Context-Aware Code Reviewer"}),"\n",(0,i.jsx)(n.p,{children:"This extension tracks code patterns across a session and suggests improvements based on accumulated knowledge."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tools::extensions::{\n    ExtensionCallback, ExtensionContext, ExtensionError, ExtensionMessage,\n    ExtensionRegistration, ExtensionRegistry, ExtensionStateConfig,\n    PromptAddition, ToolConfig\n};\n\n/// State stored across callback invocations\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct ReviewerState {\n    patterns_seen: HashMap<String, u32>,  // Pattern name \u2192 count\n    last_review_time: Option<u64>,\n    suggestions_given: Vec<String>,\n}\n\nimpl Default for ReviewerState {\n    fn default() -> Self {\n        Self {\n            patterns_seen: HashMap::new(),\n            last_review_time: None,\n            suggestions_given: Vec::new(),\n        }\n    }\n}\n\n/// Custom extension implementation\nstruct CodeReviewerExtension {\n    min_pattern_count: u32,\n}\n\nimpl CodeReviewerExtension {\n    fn new(min_pattern_count: u32) -> Self {\n        Self { min_pattern_count }\n    }\n\n    /// Detect code patterns in text\n    fn detect_patterns(&self, text: &str) -> Vec<String> {\n        let mut patterns = Vec::new();\n        \n        if text.contains("unwrap()") {\n            patterns.push("unwrap-usage".to_string());\n        }\n        if text.contains("clone()") {\n            patterns.push("clone-usage".to_string());\n        }\n        if text.contains("Arc<Mutex<") {\n            patterns.push("arc-mutex-pattern".to_string());\n        }\n        if text.contains("panic!") {\n            patterns.push("panic-usage".to_string());\n        }\n        \n        patterns\n    }\n\n    /// Generate suggestions based on accumulated state\n    fn generate_suggestions(&self, state: &ReviewerState) -> Vec<String> {\n        let mut suggestions = Vec::new();\n\n        for (pattern, count) in &state.patterns_seen {\n            if *count >= self.min_pattern_count {\n                match pattern.as_str() {\n                    "unwrap-usage" => {\n                        suggestions.push(format!(\n                            "You\'ve used unwrap() {} times. Consider using ? operator or match for better error handling.",\n                            count\n                        ));\n                    }\n                    "clone-usage" => {\n                        suggestions.push(format!(\n                            "You\'ve used clone() {} times. Consider borrowing or using Arc<T> to reduce allocations.",\n                            count\n                        ));\n                    }\n                    "arc-mutex-pattern" => {\n                        suggestions.push(format!(\n                            "You\'ve used Arc<Mutex<T>> {} times. Consider using message passing (channels) for cleaner concurrency.",\n                            count\n                        ));\n                    }\n                    "panic-usage" => {\n                        suggestions.push(format!(\n                            "You\'ve used panic! {} times. Consider returning Result<T, E> for recoverable errors.",\n                            count\n                        ));\n                    }\n                    _ => {}\n                }\n            }\n        }\n\n        suggestions\n    }\n}\n\n#[async_trait]\nimpl ExtensionCallback for CodeReviewerExtension {\n    /// Process incoming messages to detect patterns\n    async fn on_input_messages(\n        &self,\n        ctx: &mut ExtensionContext,\n        messages: Vec<ExtensionMessage>\n    ) -> Result<Vec<ExtensionMessage>, ExtensionError> {\n        // Load state\n        let mut state: ReviewerState = ctx\n            .get_state("reviewer_state")?\n            .unwrap_or_default();\n\n        // Analyze messages for patterns\n        for msg in &messages {\n            if msg.role == "user" {\n                let patterns = self.detect_patterns(&msg.content);\n                for pattern in patterns {\n                    *state.patterns_seen.entry(pattern).or_insert(0) += 1;\n                }\n            }\n        }\n\n        // Save state\n        ctx.set_state("reviewer_state", state)?;\n\n        // Pass messages through unchanged\n        Ok(messages)\n    }\n\n    /// Add code review suggestions to LLM output\n    async fn on_llm_output(\n        &self,\n        ctx: &mut ExtensionContext,\n        output: String\n    ) -> Result<String, ExtensionError> {\n        // Load state\n        let state: ReviewerState = ctx\n            .get_state("reviewer_state")?\n            .unwrap_or_default();\n\n        // Generate suggestions\n        let suggestions = self.generate_suggestions(&state);\n\n        if suggestions.is_empty() {\n            return Ok(output);\n        }\n\n        // Append suggestions to output\n        let mut enhanced = output;\n        enhanced.push_str("\\n\\n## Code Review Suggestions\\n\\n");\n        for (i, suggestion) in suggestions.iter().enumerate() {\n            enhanced.push_str(&format!("{}. {}\\n", i + 1, suggestion));\n        }\n\n        Ok(enhanced)\n    }\n}\n\n/// Register the extension\npub fn register_code_reviewer(registry: &mut ExtensionRegistry) -> Result<(), ExtensionError> {\n    let extension = Arc::new(CodeReviewerExtension::new(3));  // Suggest after 3 occurrences\n\n    let registration = ExtensionRegistration::new("code-reviewer", extension)\n        .with_priority(5)  // Medium priority\n        .with_prompt_additions(vec![\n            PromptAddition {\n                role: "system".to_string(),\n                content: "You are a code reviewer. Track patterns and provide constructive feedback.".to_string(),\n            }\n        ])\n        .with_state_config(ExtensionStateConfig {\n            max_state_size_bytes: 512 * 1024,  // 512KB\n            state_ttl_seconds: 7200,  // 2 hours\n        });\n\n    registry.register_extension(registration)?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use mk_core::types::TenantContext;\n    use tools::tools::ToolRegistry;\n\n    #[tokio::test]\n    async fn test_code_reviewer_detects_patterns() {\n        let extension = CodeReviewerExtension::new(2);\n        let tool_registry = Arc::new(ToolRegistry::new());\n        let mut ctx = ExtensionContext::new(\n            TenantContext::default(),\n            "test-session".to_string(),\n            "code-reviewer".to_string(),\n            tool_registry,\n            64 * 1024,\n        );\n\n        let messages = vec![\n            ExtensionMessage {\n                role: "user".to_string(),\n                content: "let value = map.get(\\"key\\").unwrap();".to_string(),\n            },\n            ExtensionMessage {\n                role: "user".to_string(),\n                content: "let value = map.get(\\"key2\\").unwrap();".to_string(),\n            },\n        ];\n\n        let result = extension.on_input_messages(&mut ctx, messages).await.unwrap();\n        assert_eq!(result.len(), 2);\n\n        // Check state\n        let state: ReviewerState = ctx.get_state("reviewer_state").unwrap().unwrap();\n        assert_eq!(state.patterns_seen.get("unwrap-usage"), Some(&2));\n    }\n\n    #[tokio::test]\n    async fn test_code_reviewer_generates_suggestions() {\n        let extension = CodeReviewerExtension::new(2);\n        let tool_registry = Arc::new(ToolRegistry::new());\n        let mut ctx = ExtensionContext::new(\n            TenantContext::default(),\n            "test-session".to_string(),\n            "code-reviewer".to_string(),\n            tool_registry,\n            64 * 1024,\n        );\n\n        // Set state with detected patterns\n        let mut state = ReviewerState::default();\n        state.patterns_seen.insert("unwrap-usage".to_string(), 3);\n        ctx.set_state("reviewer_state", state).unwrap();\n\n        let output = "Here\'s the code you requested.".to_string();\n        let enhanced = extension.on_llm_output(&mut ctx, output).await.unwrap();\n\n        assert!(enhanced.contains("Code Review Suggestions"));\n        assert!(enhanced.contains("unwrap()"));\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"extension-patterns",children:"Extension Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-enrichment-extension",children:"Pattern 1: Enrichment Extension"}),"\n",(0,i.jsx)(n.p,{children:"Add context from external sources:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'struct EnrichmentExtension {\n    api_client: Arc<ExternalApiClient>,\n}\n\n#[async_trait]\nimpl ExtensionCallback for EnrichmentExtension {\n    async fn on_input_messages(\n        &self,\n        ctx: &mut ExtensionContext,\n        mut messages: Vec<ExtensionMessage>\n    ) -> Result<Vec<ExtensionMessage>, ExtensionError> {\n        // Detect entities in user message\n        if let Some(last_msg) = messages.last() {\n            if last_msg.role == "user" {\n                let entities = self.extract_entities(&last_msg.content);\n                \n                // Fetch enrichment data\n                for entity in entities {\n                    if let Ok(data) = self.api_client.lookup(&entity).await {\n                        // Add enrichment as system message\n                        messages.push(ExtensionMessage {\n                            role: "system".to_string(),\n                            content: format!("Context for {}: {}", entity, data),\n                        });\n                    }\n                }\n            }\n        }\n\n        Ok(messages)\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-validation-extension",children:"Pattern 2: Validation Extension"}),"\n",(0,i.jsx)(n.p,{children:"Validate outputs before returning to user:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'struct ValidationExtension {\n    rules: Vec<ValidationRule>,\n}\n\n#[async_trait]\nimpl ExtensionCallback for ValidationExtension {\n    async fn on_llm_output(\n        &self,\n        _ctx: &mut ExtensionContext,\n        output: String\n    ) -> Result<String, ExtensionError> {\n        for rule in &self.rules {\n            if !rule.validate(&output) {\n                return Err(ExtensionError::Callback(\n                    format!("Output failed validation: {}", rule.name)\n                ));\n            }\n        }\n        Ok(output)\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-3-caching-extension",children:"Pattern 3: Caching Extension"}),"\n",(0,i.jsx)(n.p,{children:"Cache expensive operations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct CachingExtension {\n    cache: Arc<RwLock<HashMap<String, String>>>,\n}\n\n#[async_trait]\nimpl ExtensionCallback for CachingExtension {\n    async fn on_plain_text(\n        &self,\n        ctx: &mut ExtensionContext,\n        text: String\n    ) -> Result<String, ExtensionError> {\n        // Check cache\n        {\n            let cache = self.cache.read().unwrap();\n            if let Some(cached) = cache.get(&text) {\n                return Ok(cached.clone());\n            }\n        }\n\n        // Process (expensive operation)\n        let processed = self.expensive_processing(&text).await?;\n\n        // Store in cache\n        {\n            let mut cache = self.cache.write().unwrap();\n            cache.insert(text, processed.clone());\n        }\n\n        Ok(processed)\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-4-stateful-conversation-tracker",children:"Pattern 4: Stateful Conversation Tracker"}),"\n",(0,i.jsx)(n.p,{children:"Track conversation flow:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[derive(Serialize, Deserialize)]\nstruct ConversationState {\n    turn_count: u32,\n    topics: Vec<String>,\n    sentiment: f32,\n}\n\nstruct ConversationTrackerExtension;\n\n#[async_trait]\nimpl ExtensionCallback for ConversationTrackerExtension {\n    async fn on_input_messages(\n        &self,\n        ctx: &mut ExtensionContext,\n        messages: Vec<ExtensionMessage>\n    ) -> Result<Vec<ExtensionMessage>, ExtensionError> {\n        let mut state: ConversationState = ctx\n            .get_state("conversation")?\n            .unwrap_or(ConversationState {\n                turn_count: 0,\n                topics: Vec::new(),\n                sentiment: 0.0,\n            });\n\n        state.turn_count += 1;\n        \n        // Analyze topics\n        for msg in &messages {\n            if msg.role == "user" {\n                let topics = self.extract_topics(&msg.content);\n                state.topics.extend(topics);\n            }\n        }\n\n        ctx.set_state("conversation", state)?;\n        Ok(messages)\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-keep-extensions-focused",children:"1. Keep Extensions Focused"}),"\n",(0,i.jsx)(n.p,{children:"Each extension should have a single responsibility:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Good: ",(0,i.jsx)(n.code,{children:"CodeReviewerExtension"})," (reviews code)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u274c Bad: ",(0,i.jsx)(n.code,{children:"EverythingExtension"})," (reviews code, translates, validates, etc.)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-handle-state-gracefully",children:"2. Handle State Gracefully"}),"\n",(0,i.jsx)(n.p,{children:"Always provide defaults when state is missing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let state: MyState = ctx\n    .get_state("my_state")?\n    .unwrap_or_default();  // \u2705 Graceful fallback\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-validate-inputs",children:"3. Validate Inputs"}),"\n",(0,i.jsx)(n.p,{children:"Don't trust data from previous extensions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'async fn on_input_messages(\n    &self,\n    ctx: &mut ExtensionContext,\n    messages: Vec<ExtensionMessage>\n) -> Result<Vec<ExtensionMessage>, ExtensionError> {\n    if messages.is_empty() {\n        return Err(ExtensionError::Callback("Empty messages".to_string()));\n    }\n    // Continue processing...\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-use-appropriate-priorities",children:"4. Use Appropriate Priorities"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High (10+)"}),": Critical preprocessing (security, validation)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Medium (5-9)"}),": Enrichment, analysis"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Low (1-4)"}),": Formatting, cosmetic changes"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"5-limit-state-size",children:"5. Limit State Size"}),"\n",(0,i.jsx)(n.p,{children:"Monitor state size to avoid hitting limits:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let state_size = serde_json::to_vec(&state)?.len();\nif state_size > 900_000 {  // 90% of 1MB limit\n    // Trim old data\n    state.history.truncate(100);\n}\nctx.set_state("state", state)?;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"6-handle-timeouts",children:"6. Handle Timeouts"}),"\n",(0,i.jsx)(n.p,{children:"Extensions have a default 5-second timeout. For long operations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"async fn on_input_messages(\n    &self,\n    ctx: &mut ExtensionContext,\n    messages: Vec<ExtensionMessage>\n) -> Result<Vec<ExtensionMessage>, ExtensionError> {\n    // Spawn background task for long operation\n    tokio::spawn(async move {\n        self.long_running_analysis(messages.clone()).await;\n    });\n\n    // Return immediately\n    Ok(messages)\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"7-test-thoroughly",children:"7. Test Thoroughly"}),"\n",(0,i.jsx)(n.p,{children:"Write unit tests for each callback:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[tokio::test]\nasync fn test_my_extension() {\n    let ext = MyExtension::new();\n    let mut ctx = create_test_context();\n    \n    let messages = vec![test_message()];\n    let result = ext.on_input_messages(&mut ctx, messages).await;\n    \n    assert!(result.is_ok());\n    // Additional assertions...\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"debugging-extensions",children:"Debugging Extensions"}),"\n",(0,i.jsx)(n.h3,{id:"enable-debug-logging",children:"Enable Debug Logging"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use tracing::{info, debug, error};\n\nasync fn on_input_messages(\n    &self,\n    ctx: &mut ExtensionContext,\n    messages: Vec<ExtensionMessage>\n) -> Result<Vec<ExtensionMessage>, ExtensionError> {\n    debug!("Extension {} processing {} messages", ctx.extension_id, messages.len());\n    \n    let state: MyState = ctx.get_state("state")?.unwrap_or_default();\n    info!("Current state: {:?}", state);\n    \n    // Processing...\n    \n    Ok(messages)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"inspect-state",children:"Inspect State"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"ExtensionContext::state()"})," method to dump raw state:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let raw_state = ctx.state();\nprintln!("Raw state: {:#?}", raw_state);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"monitor-performance",children:"Monitor Performance"}),"\n",(0,i.jsx)(n.p,{children:"Track callback duration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::time::Instant;\n\nlet start = Instant::now();\nlet result = self.process(ctx, messages).await?;\nlet duration = start.elapsed();\n\nif duration.as_millis() > 100 {\n    warn!("Extension {} took {}ms", ctx.extension_id, duration.as_millis());\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"deployment",children:"Deployment"}),"\n",(0,i.jsx)(n.h3,{id:"opencode-plugin-integration",children:"OpenCode Plugin Integration"}),"\n",(0,i.jsx)(n.p,{children:"Extensions are registered in the OpenCode plugin:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// opencode-plugin/src/extensions/index.ts\nimport { ExtensionRegistry } from '@kiko-aeterna/opencode-plugin';\n\nconst registry = new ExtensionRegistry();\n\n// Register Rust-compiled WASM extension\nregistry.registerWasm('code-reviewer', await loadWasm('code-reviewer.wasm'));\n\n// Register JavaScript extension\nregistry.register({\n  id: 'js-formatter',\n  priority: 3,\n  callbacks: {\n    onLlmOutput: async (ctx, output) => {\n      return formatMarkdown(output);\n    }\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"state-storage-configuration",children:"State Storage Configuration"}),"\n",(0,i.jsx)(n.p,{children:"Configure Redis for state persistence:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[extensions.state]\nredis_url = "redis://localhost:6379"\ncompression = "zstd"\ncompression_level = 3\nmax_state_size_bytes = 1048576  # 1MB\ndefault_ttl_seconds = 3600  # 1 hour\n'})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Review ",(0,i.jsx)(n.a,{href:"/aeterna/docs/cca/architecture",children:"Architecture"})," to understand where extensions fit"]}),"\n",(0,i.jsxs)(n.li,{children:["Explore ",(0,i.jsx)(n.a,{href:"/aeterna/docs/cca/api-reference",children:"API Reference"})," for available MCP tools"]}),"\n",(0,i.jsxs)(n.li,{children:["See ",(0,i.jsx)(n.a,{href:"/aeterna/docs/cca/configuration",children:"Configuration"})," for extension state settings"]}),"\n",(0,i.jsxs)(n.li,{children:["Check out example extensions in ",(0,i.jsx)(n.code,{children:"tools/src/extensions/examples/"})]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);