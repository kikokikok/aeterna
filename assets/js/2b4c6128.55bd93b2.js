"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4369],{7311(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"guides/agent-governance-integration","title":"Agent Developer Guide: Governance Integration","description":"Building AI agents that work within enterprise governance frameworks","source":"@site/docs/guides/agent-governance-integration.md","sourceDirName":"guides","slug":"/guides/agent-governance-integration","permalink":"/aeterna/docs/guides/agent-governance-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/kikokikok/aeterna/tree/main/website/docs/guides/agent-governance-integration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"UX-First Governance: Natural Language Policy Management","permalink":"/aeterna/docs/guides/ux-first-governance"},"next":{"title":"CCA: Confucius Code Agent Capabilities","permalink":"/aeterna/docs/cca/overview"}}');var i=t(4848),s=t(8453);const a={},o="Agent Developer Guide: Governance Integration",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Why Agent Governance Matters",id:"why-agent-governance-matters",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Delegation Chain",id:"delegation-chain",level:3},{value:"Capability Model",id:"capability-model",level:3},{value:"Authorization Flow",id:"authorization-flow",level:3},{value:"Agent Registration",id:"agent-registration",level:2},{value:"CLI Registration",id:"cli-registration",level:3},{value:"Programmatic Registration",id:"programmatic-registration",level:3},{value:"Agent Types",id:"agent-types",level:3},{value:"Authentication",id:"authentication",level:2},{value:"Token-Based Auth",id:"token-based-auth",level:3},{value:"Environment Configuration",id:"environment-configuration",level:3},{value:"Permission Model",id:"permission-model",level:2},{value:"Capability Sets",id:"capability-sets",level:3},{value:"Scope Inheritance",id:"scope-inheritance",level:3},{value:"Delegation Depth",id:"delegation-depth",level:3},{value:"Memory Access Patterns",id:"memory-access-patterns",level:2},{value:"Reading Memory",id:"reading-memory",level:3},{value:"Writing Memory",id:"writing-memory",level:3},{value:"Memory Promotion",id:"memory-promotion",level:3},{value:"Knowledge Access Patterns",id:"knowledge-access-patterns",level:2},{value:"Querying Knowledge",id:"querying-knowledge",level:3},{value:"Proposing Knowledge",id:"proposing-knowledge",level:3},{value:"Policy Interaction",id:"policy-interaction",level:2},{value:"Checking Constraints",id:"checking-constraints",level:3},{value:"Proposing Policies",id:"proposing-policies",level:3},{value:"Simulating Policies",id:"simulating-policies",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Request Minimal Capabilities",id:"1-request-minimal-capabilities",level:3},{value:"2. Check Constraints Before Acting",id:"2-check-constraints-before-acting",level:3},{value:"3. Handle Permission Denials Gracefully",id:"3-handle-permission-denials-gracefully",level:3},{value:"4. Use Scoped Operations",id:"4-use-scoped-operations",level:3},{value:"5. Audit Your Actions",id:"5-audit-your-actions",level:3},{value:"6. Propose, Don&#39;t Modify Directly",id:"6-propose-dont-modify-directly",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Complete Agent Implementation",id:"complete-agent-implementation",level:3},{value:"OpenCode Integration Example",id:"opencode-integration-example",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"agent-developer-guide-governance-integration",children:"Agent Developer Guide: Governance Integration"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Building AI agents that work within enterprise governance frameworks"})}),"\n",(0,i.jsx)(n.p,{children:"This guide covers how to integrate AI agents (OpenCode, LangChain, AutoGen, CrewAI, custom) with Aeterna's governance system. You'll learn how agents authenticate, receive delegated permissions, and interact with memory and knowledge within policy constraints."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#core-concepts",children:"Core Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#delegation-chain",children:"Delegation Chain"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#capability-model",children:"Capability Model"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#authorization-flow",children:"Authorization Flow"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#agent-registration",children:"Agent Registration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#cli-registration",children:"CLI Registration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#programmatic-registration",children:"Programmatic Registration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#agent-types",children:"Agent Types"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#authentication",children:"Authentication"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#token-based-auth",children:"Token-Based Auth"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#environment-configuration",children:"Environment Configuration"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#permission-model",children:"Permission Model"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#capability-sets",children:"Capability Sets"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#scope-inheritance",children:"Scope Inheritance"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#delegation-depth",children:"Delegation Depth"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#memory-access-patterns",children:"Memory Access Patterns"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#reading-memory",children:"Reading Memory"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#writing-memory",children:"Writing Memory"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#memory-promotion",children:"Memory Promotion"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#knowledge-access-patterns",children:"Knowledge Access Patterns"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#querying-knowledge",children:"Querying Knowledge"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#proposing-knowledge",children:"Proposing Knowledge"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#policy-interaction",children:"Policy Interaction"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#checking-constraints",children:"Checking Constraints"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#proposing-policies",children:"Proposing Policies"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#simulating-policies",children:"Simulating Policies"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#error-handling",children:"Error Handling"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#code-examples",children:"Code Examples"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Aeterna provides a comprehensive governance framework for AI agents operating in enterprise environments. Unlike traditional access control, Aeterna uses:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Delegation-Based Access"}),": Agents inherit permissions from a delegating user"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Capability Tokens"}),": Explicit, auditable permissions like ",(0,i.jsx)(n.code,{children:"memory:read"}),", ",(0,i.jsx)(n.code,{children:"knowledge:propose"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cedar Policies"}),": Fine-grained authorization rules evaluated in real-time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scope Constraints"}),": Access limited by organizational hierarchy (company/org/team/project)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"why-agent-governance-matters",children:"Why Agent Governance Matters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Challenge"}),(0,i.jsx)(n.th,{children:"Without Governance"}),(0,i.jsx)(n.th,{children:"With Aeterna Governance"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Data leakage"}),(0,i.jsx)(n.td,{children:"Agent accesses any data"}),(0,i.jsx)(n.td,{children:"Agent only sees delegator's accessible data"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Privilege escalation"}),(0,i.jsx)(n.td,{children:"Agent does things user cannot"}),(0,i.jsx)(n.td,{children:"Agent cannot exceed delegator's permissions"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Audit trail"}),(0,i.jsx)(n.td,{children:"No traceability"}),(0,i.jsx)(n.td,{children:"Full audit log of agent actions"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Policy compliance"}),(0,i.jsx)(n.td,{children:"Manual enforcement"}),(0,i.jsx)(n.td,{children:"Automatic Cedar policy evaluation"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Multi-tenant isolation"}),(0,i.jsx)(n.td,{children:"Risk of cross-tenant access"}),(0,i.jsx)(n.td,{children:"Hierarchical isolation guaranteed"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"delegation-chain",children:"Delegation Chain"}),"\n",(0,i.jsxs)(n.p,{children:["Every agent operates under a ",(0,i.jsx)(n.strong,{children:"delegation chain"})," - a traceable path from the agent back to a human principal:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Human User (alice@acme.com)\n    \u2502\n    \u251c\u2500\u2500 delegates to \u2500\u2500\u25ba Agent: opencode-alice\n    \u2502                         \u2502\n    \u2502                         \u2514\u2500\u2500 delegates to \u2500\u2500\u25ba Sub-agent: opencode-alice-task-1\n    \u2502\n    \u2514\u2500\u2500 has role: developer\n        \u2514\u2500\u2500 in team: api-team\n            \u2514\u2500\u2500 in org: platform-engineering\n                \u2514\u2500\u2500 in company: acme-corp\n"})}),"\n",(0,i.jsx)(n.p,{children:"Key properties:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"delegation_depth"}),": Number of hops from original human (default max: 3)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"delegated_by"}),": Reference to parent principal (user or agent)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"capabilities"}),": Subset of delegator's permissions"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"capability-model",children:"Capability Model"}),"\n",(0,i.jsxs)(n.p,{children:["Agents receive explicit ",(0,i.jsx)(n.strong,{children:"capabilities"})," - not roles. This provides fine-grained control:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Capability"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Typical Use"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"memory:read"})}),(0,i.jsx)(n.td,{children:"Search and retrieve memories"}),(0,i.jsx)(n.td,{children:"All agents"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"memory:write"})}),(0,i.jsx)(n.td,{children:"Add new memories"}),(0,i.jsx)(n.td,{children:"Most agents"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"memory:delete"})}),(0,i.jsx)(n.td,{children:"Delete memories"}),(0,i.jsx)(n.td,{children:"Restricted"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"memory:promote"})}),(0,i.jsx)(n.td,{children:"Promote memory to higher layer"}),(0,i.jsx)(n.td,{children:"Restricted"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"knowledge:read"})}),(0,i.jsx)(n.td,{children:"Query knowledge repository"}),(0,i.jsx)(n.td,{children:"All agents"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"knowledge:propose"})}),(0,i.jsx)(n.td,{children:"Propose new knowledge items"}),(0,i.jsx)(n.td,{children:"Most agents"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"knowledge:edit"})}),(0,i.jsx)(n.td,{children:"Modify existing knowledge"}),(0,i.jsx)(n.td,{children:"Restricted"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"policy:read"})}),(0,i.jsx)(n.td,{children:"View and check constraints"}),(0,i.jsx)(n.td,{children:"All agents"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"policy:create"})}),(0,i.jsx)(n.td,{children:"Create policy drafts"}),(0,i.jsx)(n.td,{children:"Restricted"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"policy:simulate"})}),(0,i.jsx)(n.td,{children:"Test policy effects"}),(0,i.jsx)(n.td,{children:"Most agents"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"governance:read"})}),(0,i.jsx)(n.td,{children:"View governance requests"}),(0,i.jsx)(n.td,{children:"All agents"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"governance:submit"})}),(0,i.jsx)(n.td,{children:"Submit for approval"}),(0,i.jsx)(n.td,{children:"Most agents"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"org:read"})}),(0,i.jsx)(n.td,{children:"View organization structure"}),(0,i.jsx)(n.td,{children:"All agents"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"agent:register"})}),(0,i.jsx)(n.td,{children:"Register sub-agents"}),(0,i.jsx)(n.td,{children:"Autonomous agents only"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"agent:delegate"})}),(0,i.jsx)(n.td,{children:"Delegate to other agents"}),(0,i.jsx)(n.td,{children:"Autonomous agents only"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"authorization-flow",children:"Authorization Flow"}),"\n",(0,i.jsx)(n.p,{children:"Every agent action goes through Cedar policy evaluation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         AUTHORIZATION FLOW                                   \u2502\n\u2502                                                                              \u2502\n\u2502   1. Agent Request                                                           \u2502\n\u2502      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u2502\n\u2502      \u2502 Agent: opencode-alice                      \u2502                         \u2502\n\u2502      \u2502 Action: CreateMemory                       \u2502                         \u2502\n\u2502      \u2502 Resource: memory in project:payments      \u2502                         \u2502\n\u2502      \u2502 Content: "Use bcrypt for password hashing" \u2502                         \u2502\n\u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502\n\u2502                            \u2502                                                 \u2502\n\u2502   2. Cedar Policy Evaluation                                                \u2502\n\u2502      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u2502\n\u2502      \u2502 CHECK: Is agent active?           \u2713        \u2502                         \u2502\n\u2502      \u2502 CHECK: delegation_depth <= max?   \u2713        \u2502                         \u2502\n\u2502      \u2502 CHECK: Has memory:write cap?      \u2713        \u2502                         \u2502\n\u2502      \u2502 CHECK: Resource in scope?         \u2713        \u2502                         \u2502\n\u2502      \u2502 CHECK: No forbid policy matches?  \u2713        \u2502                         \u2502\n\u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502\n\u2502                            \u2502                                                 \u2502\n\u2502   3. Decision                                                                \u2502\n\u2502      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u2502\n\u2502      \u2502 PERMIT: Memory created                     \u2502                         \u2502\n\u2502      \u2502 Audit: Logged with full context            \u2502                         \u2502\n\u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"agent-registration",children:"Agent Registration"}),"\n",(0,i.jsx)(n.h3,{id:"cli-registration",children:"CLI Registration"}),"\n",(0,i.jsx)(n.p,{children:"The simplest way to register an agent:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Basic registration (inherits from current user)\n$ aeterna agent register my-coding-assistant \\\n    --description "AI coding assistant for payments project" \\\n    --agent-type opencode\n\n\u2705 Agent registered: agent-my-coding-assistant-1234\n\nDelegation chain:\n  alice@acme.com\n    \u2192 team:api-team\n    \u2192 org:platform-engineering\n    \u2192 company:acme-corp\n\nCapabilities (delegated from alice@acme.com):\n  \u2022 memory:read    - Search and retrieve memories\n  \u2022 memory:write   - Add new memories\n  \u2022 knowledge:read - Query knowledge repository\n  \u2022 policy:read    - Check constraints\n\nToken: aeterna_agent_abc123xyz (save securely)\n\nConfigure your AI assistant:\n  export AETERNA_AGENT_ID="agent-my-coding-assistant-1234"\n  export AETERNA_AGENT_TOKEN="aeterna_agent_abc123xyz"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"With explicit user delegation:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'$ aeterna agent register autonomous-reviewer \\\n    --delegated-by alice@acme.com \\\n    --agent-type custom \\\n    --description "Autonomous code review agent"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Dry run to preview:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ aeterna agent register test-agent --agent-type langchain --dry-run\n\nAgent Registration (Dry Run)\n\n  Agent ID:     agent-test-agent-5678\n  Name:         test-agent\n  Type:         langchain\n  Delegated By: alice@acme.com\n\nWhat Would Happen:\n  1. Create agent identity 'agent-test-agent-5678'\n  2. Delegate permissions from 'alice@acme.com' to agent\n  3. Generate Cedar policies for agent authorization\n  4. Agent inherits user's permissions (scoped down)\n\nDefault Permissions (inherited from delegating user):\n  - memory:read    - Search and retrieve memories\n  - memory:write   - Add new memories\n  - knowledge:read - Query knowledge repository\n  - policy:read    - Check constraints (no create/modify)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"programmatic-registration",children:"Programmatic Registration"}),"\n",(0,i.jsx)(n.p,{children:"For automated agent provisioning in Rust:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_tools::governance::{AgentRegistration, AgentType};\nuse aeterna_context::ContextResolver;\n\nasync fn register_agent() -> anyhow::Result<String> {\n    // Resolve current context (auto-detects user, project, team from git)\n    let resolver = ContextResolver::new();\n    let context = resolver.resolve()?;\n    \n    // Create registration request\n    let registration = AgentRegistration {\n        name: "my-ai-assistant".to_string(),\n        description: Some("AI assistant for code generation".to_string()),\n        agent_type: AgentType::OpenCode,\n        delegated_by: context.user_id.value.clone(),\n        capabilities: vec![\n            "memory:read".to_string(),\n            "memory:write".to_string(),\n            "knowledge:read".to_string(),\n            "knowledge:propose".to_string(),\n            "policy:read".to_string(),\n            "policy:simulate".to_string(),\n        ],\n        scope: Some(context.project_id.value.clone()),\n        max_delegation_depth: 2,\n        expires_at: None, // Optional expiration\n    };\n    \n    // Register via governance client\n    let client = GovernanceClient::new(&context).await?;\n    let agent = client.register_agent(registration).await?;\n    \n    println!("Agent ID: {}", agent.agent_id);\n    println!("Token: {}", agent.token);\n    \n    Ok(agent.agent_id)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"agent-types",children:"Agent Types"}),"\n",(0,i.jsx)(n.p,{children:"Aeterna recognizes several agent types with different default capabilities:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Default Capabilities"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"opencode"})}),(0,i.jsx)(n.td,{children:"AI coding assistant"}),(0,i.jsx)(n.td,{children:"memory:read/write, knowledge:read/propose, policy:read/simulate"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"langchain"})}),(0,i.jsx)(n.td,{children:"LangChain-based agent"}),(0,i.jsx)(n.td,{children:"memory:read/write, knowledge:read, policy:read"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"autogen"})}),(0,i.jsx)(n.td,{children:"Microsoft AutoGen agent"}),(0,i.jsx)(n.td,{children:"memory:read/write, knowledge:read, governance:read"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"crewai"})}),(0,i.jsx)(n.td,{children:"CrewAI multi-agent"}),(0,i.jsx)(n.td,{children:"memory:read/write, knowledge:read, agent:register"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"custom"})}),(0,i.jsx)(n.td,{children:"Custom agent"}),(0,i.jsx)(n.td,{children:"memory:read, knowledge:read, policy:read (minimal)"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsx)(n.h3,{id:"token-based-auth",children:"Token-Based Auth"}),"\n",(0,i.jsx)(n.p,{children:"Agents authenticate using bearer tokens issued at registration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_tools::client::AeternaClient;\n\nasync fn create_authenticated_client() -> anyhow::Result<AeternaClient> {\n    let agent_id = std::env::var("AETERNA_AGENT_ID")?;\n    let agent_token = std::env::var("AETERNA_AGENT_TOKEN")?;\n    \n    let client = AeternaClient::builder()\n        .agent_id(&agent_id)\n        .agent_token(&agent_token)\n        .build()\n        .await?;\n    \n    Ok(client)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"environment-configuration",children:"Environment Configuration"}),"\n",(0,i.jsx)(n.p,{children:"Standard environment variables for agent configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Required\nexport AETERNA_AGENT_ID="agent-my-assistant-1234"\nexport AETERNA_AGENT_TOKEN="aeterna_agent_abc123xyz"\n\n# Optional - override auto-detection\nexport AETERNA_ENDPOINT="https://aeterna.acme.com"\nexport AETERNA_TENANT_ID="acme-corp"\nexport AETERNA_PROJECT="payments-service"\n\n# For local development\nexport AETERNA_ENDPOINT="http://localhost:8080"\nexport AETERNA_SKIP_TLS_VERIFY="true"\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Configuration file alternative"})," (",(0,i.jsx)(n.code,{children:".aeterna/agent.toml"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[agent]\nid = "agent-my-assistant-1234"\n# token loaded from AETERNA_AGENT_TOKEN env var for security\n\n[connection]\nendpoint = "https://aeterna.acme.com"\ntimeout_ms = 30000\n\n[context]\ntenant_id = "acme-corp"\n# project auto-detected from git remote\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"permission-model",children:"Permission Model"}),"\n",(0,i.jsx)(n.h3,{id:"capability-sets",children:"Capability Sets"}),"\n",(0,i.jsx)(n.p,{children:"Agents receive capabilities based on their purpose. Here are recommended sets:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Standard AI Coding Assistant:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let capabilities = vec![\n    "memory:read",     // Search past decisions\n    "memory:write",    // Store new learnings\n    "knowledge:read",  // Query ADRs, patterns\n    "knowledge:propose", // Suggest new patterns\n    "policy:read",     // Check constraints\n    "policy:simulate", // Test policy effects\n    "governance:read", // View pending approvals\n    "governance:submit", // Submit proposals\n    "org:read",        // View team structure\n];\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Autonomous Agent (higher trust):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let capabilities = vec![\n    "memory:read",\n    "memory:write",\n    "memory:delete",      // Can clean up memories\n    "memory:promote",     // Can promote to higher layers\n    "knowledge:read",\n    "knowledge:propose",\n    "knowledge:edit",     // Can modify knowledge\n    "policy:read",\n    "policy:create",      // Can create policy drafts\n    "policy:simulate",\n    "governance:read",\n    "governance:submit",\n    "org:read",\n    "agent:register",     // Can create sub-agents\n    "agent:delegate",     // Can delegate to sub-agents\n];\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Read-Only Agent:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let capabilities = vec![\n    "memory:read",\n    "knowledge:read",\n    "policy:read",\n    "governance:read",\n    "org:read",\n];\n'})}),"\n",(0,i.jsx)(n.h3,{id:"scope-inheritance",children:"Scope Inheritance"}),"\n",(0,i.jsx)(n.p,{children:"Agent scope is constrained by the delegating user's scope:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"User: alice@acme.com\n\u251c\u2500\u2500 Scope: org:platform-engineering (and below)\n\u2502\n\u2514\u2500\u2500 Agent: opencode-alice\n    \u251c\u2500\u2500 Scope: project:payments-service (narrower)\n    \u2502   \u2713 Can access: project:payments-service\n    \u2502   \u2713 Can access: team:api-team (inherited)\n    \u2502   \u2717 Cannot access: project:auth-service (different project)\n    \u2502\n    \u2514\u2500\u2500 Capabilities: memory:read, memory:write, knowledge:read\n"})}),"\n",(0,i.jsx)(n.h3,{id:"delegation-depth",children:"Delegation Depth"}),"\n",(0,i.jsx)(n.p,{children:"Agents can delegate to sub-agents, but depth is limited:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Human (depth: 0)\n    \u2514\u2500\u2500 Agent A (depth: 1)\n        \u2514\u2500\u2500 Sub-agent B (depth: 2)\n            \u2514\u2500\u2500 Sub-agent C (depth: 3) \u2190 Max depth reached\n                \u2514\u2500\u2500 \u2717 Cannot delegate further\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cedar policy enforcing depth:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cedar",children:'permit (\n    principal is Aeterna::Agent,\n    action == Aeterna::Action::"CreateMemory",\n    resource\n)\nwhen {\n    principal.status == "active" &&\n    principal.delegation_depth <= principal.max_delegation_depth &&\n    principal.capabilities.contains("memory:write")\n};\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"memory-access-patterns",children:"Memory Access Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"reading-memory",children:"Reading Memory"}),"\n",(0,i.jsx)(n.p,{children:"Search memories within the agent's accessible scope:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_memory::{MemoryManager, SearchRequest};\n\nasync fn search_memories(client: &AeternaClient) -> anyhow::Result<()> {\n    let search = SearchRequest {\n        query: "database selection decisions".to_string(),\n        layers: None, // Search all accessible layers\n        min_relevance: Some(0.7),\n        limit: Some(10),\n        tags: None,\n    };\n    \n    let results = client.memory().search(search).await?;\n    \n    for memory in results.memories {\n        println!("[{:.0}%] {} - {}", \n            memory.relevance * 100.0,\n            memory.layer,\n            memory.content\n        );\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Layer-specific search:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let search = SearchRequest {\n    query: "team coding standards".to_string(),\n    layers: Some(vec!["team".to_string(), "org".to_string()]),\n    ..Default::default()\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"writing-memory",children:"Writing Memory"}),"\n",(0,i.jsx)(n.p,{children:"Store memories within permitted scope:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_memory::{MemoryManager, MemoryLayer, CreateMemoryRequest};\n\nasync fn store_memory(client: &AeternaClient) -> anyhow::Result<String> {\n    let request = CreateMemoryRequest {\n        content: "Decided to use bcrypt with cost factor 12 for password hashing".to_string(),\n        layer: MemoryLayer::Project, // Agent can write to project layer\n        tags: Some(vec!["security".to_string(), "authentication".to_string()]),\n        metadata: None,\n    };\n    \n    let memory = client.memory().create(request).await?;\n    \n    println!("Memory created: {}", memory.id);\n    Ok(memory.id)\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Error handling for permission denied:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'match client.memory().create(request).await {\n    Ok(memory) => println!("Created: {}", memory.id),\n    Err(AeternaError::PermissionDenied { action, resource }) => {\n        eprintln!("Cannot {} on {}: insufficient permissions", action, resource);\n        eprintln!("Required capability: memory:write");\n    }\n    Err(e) => return Err(e.into()),\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"memory-promotion",children:"Memory Promotion"}),"\n",(0,i.jsxs)(n.p,{children:["Promote high-value memories to broader scope (requires ",(0,i.jsx)(n.code,{children:"memory:promote"})," capability):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_memory::PromoteMemoryRequest;\n\nasync fn promote_memory(\n    client: &AeternaClient, \n    memory_id: &str\n) -> anyhow::Result<()> {\n    let request = PromoteMemoryRequest {\n        memory_id: memory_id.to_string(),\n        target_layer: MemoryLayer::Team,\n        reason: "This gotcha applies to all team members".to_string(),\n    };\n    \n    // This may require approval depending on governance config\n    let result = client.memory().promote(request).await?;\n    \n    match result {\n        PromoteResult::Promoted { new_id } => {\n            println!("Memory promoted: {}", new_id);\n        }\n        PromoteResult::PendingApproval { proposal_id } => {\n            println!("Promotion submitted for approval: {}", proposal_id);\n        }\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"knowledge-access-patterns",children:"Knowledge Access Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"querying-knowledge",children:"Querying Knowledge"}),"\n",(0,i.jsx)(n.p,{children:"Search ADRs, patterns, and policies:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_knowledge::{KnowledgeQuery, KnowledgeType};\n\nasync fn query_knowledge(client: &AeternaClient) -> anyhow::Result<()> {\n    let query = KnowledgeQuery {\n        search: "authentication".to_string(),\n        types: Some(vec![KnowledgeType::Adr, KnowledgeType::Pattern]),\n        layers: None, // All accessible layers\n        tags: None,\n    };\n    \n    let results = client.knowledge().query(query).await?;\n    \n    for item in results.items {\n        println!("[{}] {} - {}", item.item_type, item.title, item.layer);\n        println!("  Summary: {}", item.summary);\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"proposing-knowledge",children:"Proposing Knowledge"}),"\n",(0,i.jsxs)(n.p,{children:["Agents can propose new knowledge items (requires ",(0,i.jsx)(n.code,{children:"knowledge:propose"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_knowledge::{ProposeKnowledgeRequest, KnowledgeType};\n\nasync fn propose_pattern(client: &AeternaClient) -> anyhow::Result<()> {\n    let proposal = ProposeKnowledgeRequest {\n        title: "API Pagination Pattern".to_string(),\n        item_type: KnowledgeType::Pattern,\n        content: r#"\n## Context\nAPIs returning large collections need pagination.\n\n## Solution\nUse cursor-based pagination with `limit` and `after` parameters.\n\n## Example\n```json\n{\n  "data": [...],\n  "pagination": {\n    "has_more": true,\n    "next_cursor": "abc123"\n  }\n}\n```\n        "#.to_string(),\n        layer: KnowledgeLayer::Team,\n        tags: vec!["api".to_string(), "pagination".to_string()],\n        justification: "Standard pattern for all team APIs".to_string(),\n    };\n    \n    let result = client.knowledge().propose(proposal).await?;\n    \n    println!("Proposal submitted: {}", result.proposal_id);\n    println!("Notified: {:?}", result.approvers);\n    \n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"policy-interaction",children:"Policy Interaction"}),"\n",(0,i.jsx)(n.h3,{id:"checking-constraints",children:"Checking Constraints"}),"\n",(0,i.jsx)(n.p,{children:"Before taking actions, agents should check policy constraints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_tools::policy::{CheckConstraintRequest, ConstraintContext};\n\nasync fn check_dependency(\n    client: &AeternaClient, \n    dependency: &str\n) -> anyhow::Result<bool> {\n    let check = CheckConstraintRequest {\n        context: ConstraintContext::Dependency {\n            name: dependency.to_string(),\n            version: None,\n        },\n    };\n    \n    let result = client.policy().check(check).await?;\n    \n    if result.violations.is_empty() {\n        println!("\u2705 {} is allowed", dependency);\n        return Ok(true);\n    }\n    \n    for violation in &result.violations {\n        match violation.severity {\n            Severity::Block => {\n                println!("\u274c BLOCKED: {}", violation.message);\n                println!("   Policy: {} ({})", violation.policy_id, violation.layer);\n                if let Some(ref suggestion) = violation.suggestion {\n                    println!("   Suggestion: {}", suggestion);\n                }\n            }\n            Severity::Warn => {\n                println!("\u26a0\ufe0f  WARNING: {}", violation.message);\n            }\n            Severity::Info => {\n                println!("\u2139\ufe0f  INFO: {}", violation.message);\n            }\n        }\n    }\n    \n    Ok(!result.has_blocking())\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"proposing-policies",children:"Proposing Policies"}),"\n",(0,i.jsxs)(n.p,{children:["Agents with ",(0,i.jsx)(n.code,{children:"policy:create"})," can draft policies:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_tools::policy_translator::{PolicyTranslator, TranslationContext};\n\nasync fn propose_policy(client: &AeternaClient) -> anyhow::Result<()> {\n    // Use natural language - translation happens automatically\n    let natural_language = "Block MySQL in this project";\n    \n    let context = TranslationContext {\n        scope: PolicyScope::Project,\n        project: Some("payments-service".to_string()),\n        team: Some("api-team".to_string()),\n        org: Some("platform-engineering".to_string()),\n        hints: vec![],\n    };\n    \n    // Translate to Cedar policy\n    let draft = client.policy().translate(natural_language, &context).await?;\n    \n    println!("Draft created: {}", draft.draft_id);\n    println!("Generated Cedar:");\n    println!("{}", draft.cedar);\n    println!();\n    println!("Explanation: {}", draft.explanation);\n    \n    // Validate before submitting\n    if !draft.validation.syntax_valid {\n        println!("Validation errors:");\n        for err in &draft.validation.errors {\n            println!("  - {}: {}", err.error_type, err.message);\n        }\n        return Ok(());\n    }\n    \n    // Submit for approval\n    let proposal = client.policy().submit_draft(\n        &draft.draft_id,\n        "Blocking MySQL per ADR-042 (use PostgreSQL)",\n    ).await?;\n    \n    println!("Submitted for approval: {}", proposal.proposal_id);\n    \n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"simulating-policies",children:"Simulating Policies"}),"\n",(0,i.jsx)(n.p,{children:"Test policy effects before proposing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_tools::policy::SimulateRequest;\n\nasync fn simulate_policy(client: &AeternaClient, cedar: &str) -> anyhow::Result<()> {\n    let simulation = SimulateRequest {\n        cedar: cedar.to_string(),\n        scenarios: vec![\n            // Test current project state\n            SimulationScenario::CurrentProject,\n            // Test hypothetical scenario\n            SimulationScenario::Hypothetical {\n                dependencies: vec!["mysql".to_string()],\n                files: vec![],\n            },\n        ],\n    };\n    \n    let results = client.policy().simulate(simulation).await?;\n    \n    for result in &results.scenarios {\n        println!("{}: {}", \n            result.scenario_name,\n            if result.passed { "\u2705 PASS" } else { "\u274c FAIL" }\n        );\n        if !result.passed {\n            println!("  Reason: {}", result.reason);\n        }\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"Common errors and how to handle them:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use aeterna_errors::AeternaError;\n\nasync fn handle_errors(client: &AeternaClient) -> anyhow::Result<()> {\n    match client.memory().search(query).await {\n        Ok(results) => { /* process results */ }\n        \n        // Permission denied - agent lacks required capability\n        Err(AeternaError::PermissionDenied { action, resource }) => {\n            log::warn!(\n                "Permission denied: {} on {} - agent may need additional capabilities",\n                action, resource\n            );\n        }\n        \n        // Scope violation - trying to access outside allowed hierarchy\n        Err(AeternaError::ScopeViolation { requested, allowed }) => {\n            log::warn!(\n                "Cannot access {}: agent scope limited to {}",\n                requested, allowed\n            );\n        }\n        \n        // Delegation depth exceeded\n        Err(AeternaError::DelegationDepthExceeded { current, max }) => {\n            log::error!(\n                "Cannot perform action: delegation depth {} exceeds max {}",\n                current, max\n            );\n        }\n        \n        // Agent revoked or expired\n        Err(AeternaError::AgentInactive { reason }) => {\n            log::error!("Agent is inactive: {}", reason);\n            // Re-registration may be needed\n        }\n        \n        // Policy violation\n        Err(AeternaError::PolicyViolation { policy_id, message }) => {\n            log::warn!("Action blocked by policy {}: {}", policy_id, message);\n        }\n        \n        // Other errors\n        Err(e) => return Err(e.into()),\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-request-minimal-capabilities",children:"1. Request Minimal Capabilities"}),"\n",(0,i.jsx)(n.p,{children:"Only request capabilities your agent actually needs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// \u274c Don\'t request everything\nlet caps = vec!["memory:*", "knowledge:*", "policy:*"];\n\n// \u2705 Request only what you need\nlet caps = vec!["memory:read", "memory:write", "knowledge:read"];\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-check-constraints-before-acting",children:"2. Check Constraints Before Acting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// \u2705 Always check before using a dependency\nif !check_dependency(client, "mysql").await? {\n    // Use alternative or report to user\n    println!("Cannot use MySQL - use PostgreSQL instead");\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-handle-permission-denials-gracefully",children:"3. Handle Permission Denials Gracefully"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// \u2705 Graceful degradation\nmatch client.memory().promote(request).await {\n    Ok(_) => println!("Memory promoted"),\n    Err(AeternaError::PermissionDenied { .. }) => {\n        // Fall back to suggesting promotion to user\n        println!("I don\'t have permission to promote this memory.");\n        println!("You can do it with: aeterna memory promote {}", memory_id);\n    }\n    Err(e) => return Err(e.into()),\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-use-scoped-operations",children:"4. Use Scoped Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// \u2705 Explicitly scope operations\nlet search = SearchRequest {\n    query: "authentication".to_string(),\n    layers: Some(vec!["project".to_string(), "team".to_string()]),\n    ..Default::default()\n};\n\n// \u274c Avoid searching all layers when you only need project context\nlet search = SearchRequest {\n    query: "authentication".to_string(),\n    layers: None, // Searches everything - may be slow\n    ..Default::default()\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"5-audit-your-actions",children:"5. Audit Your Actions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// \u2705 Include context in memory content for auditability\nlet memory = CreateMemoryRequest {\n    content: format!(\n        "Decided to use bcrypt for password hashing (cost factor 12). \\\n         Rationale: industry standard, recommended in OWASP guidelines. \\\n         Agent: {}", \n        agent_id\n    ),\n    ..Default::default()\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"6-propose-dont-modify-directly",children:"6. Propose, Don't Modify Directly"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// \u2705 Propose changes for human review\nclient.knowledge().propose(proposal).await?;\n\n// \u274c Don't directly edit knowledge (even if you have the capability)\n// This bypasses governance workflow\nclient.knowledge().edit(item_id, new_content).await?;\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,i.jsx)(n.h3,{id:"complete-agent-implementation",children:"Complete Agent Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'//! Example: AI coding assistant agent with governance integration\n\nuse aeterna_tools::client::AeternaClient;\nuse aeterna_memory::{MemoryLayer, SearchRequest, CreateMemoryRequest};\nuse aeterna_knowledge::KnowledgeQuery;\nuse aeterna_tools::policy::CheckConstraintRequest;\nuse anyhow::Result;\n\npub struct CodingAssistant {\n    client: AeternaClient,\n    agent_id: String,\n}\n\nimpl CodingAssistant {\n    /// Create a new coding assistant from environment variables\n    pub async fn new() -> Result<Self> {\n        let agent_id = std::env::var("AETERNA_AGENT_ID")?;\n        let agent_token = std::env::var("AETERNA_AGENT_TOKEN")?;\n        \n        let client = AeternaClient::builder()\n            .agent_id(&agent_id)\n            .agent_token(&agent_token)\n            .build()\n            .await?;\n        \n        Ok(Self { client, agent_id })\n    }\n    \n    /// Search for relevant context before generating code\n    pub async fn get_context(&self, task: &str) -> Result<String> {\n        let mut context = String::new();\n        \n        // Search memories for past decisions\n        let memories = self.client.memory().search(SearchRequest {\n            query: task.to_string(),\n            layers: Some(vec!["project".to_string(), "team".to_string()]),\n            min_relevance: Some(0.7),\n            limit: Some(5),\n            ..Default::default()\n        }).await?;\n        \n        if !memories.memories.is_empty() {\n            context.push_str("## Relevant Past Decisions\\n\\n");\n            for m in &memories.memories {\n                context.push_str(&format!("- {}\\n", m.content));\n            }\n            context.push(\'\\n\');\n        }\n        \n        // Search knowledge for patterns and ADRs\n        let knowledge = self.client.knowledge().query(KnowledgeQuery {\n            search: task.to_string(),\n            types: None,\n            layers: None,\n            tags: None,\n        }).await?;\n        \n        if !knowledge.items.is_empty() {\n            context.push_str("## Applicable Knowledge\\n\\n");\n            for k in &knowledge.items {\n                context.push_str(&format!("### {}\\n{}\\n\\n", k.title, k.summary));\n            }\n        }\n        \n        Ok(context)\n    }\n    \n    /// Check if a dependency can be used\n    pub async fn can_use_dependency(&self, dep: &str) -> Result<(bool, Option<String>)> {\n        let result = self.client.policy().check(CheckConstraintRequest {\n            context: ConstraintContext::Dependency {\n                name: dep.to_string(),\n                version: None,\n            },\n        }).await?;\n        \n        if result.violations.is_empty() {\n            return Ok((true, None));\n        }\n        \n        let blocking = result.violations.iter()\n            .find(|v| v.severity == Severity::Block);\n        \n        if let Some(violation) = blocking {\n            Ok((false, violation.suggestion.clone()))\n        } else {\n            // Only warnings, can proceed\n            Ok((true, None))\n        }\n    }\n    \n    /// Store a decision for future reference\n    pub async fn remember_decision(&self, decision: &str, tags: Vec<String>) -> Result<String> {\n        let memory = self.client.memory().create(CreateMemoryRequest {\n            content: decision.to_string(),\n            layer: MemoryLayer::Project,\n            tags: Some(tags),\n            metadata: None,\n        }).await?;\n        \n        Ok(memory.id)\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let assistant = CodingAssistant::new().await?;\n    \n    // Get context for a task\n    let context = assistant.get_context("implement user authentication").await?;\n    println!("Context:\\n{}", context);\n    \n    // Check if we can use a library\n    let (can_use, suggestion) = assistant.can_use_dependency("bcrypt").await?;\n    if can_use {\n        println!("\u2705 Can use bcrypt");\n    } else {\n        println!("\u274c Cannot use bcrypt");\n        if let Some(s) = suggestion {\n            println!("   Suggestion: {}", s);\n        }\n    }\n    \n    // Store a decision\n    let memory_id = assistant.remember_decision(\n        "Using bcrypt with cost factor 12 for password hashing",\n        vec!["security".to_string(), "auth".to_string()],\n    ).await?;\n    println!("Stored decision: {}", memory_id);\n    \n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"opencode-integration-example",children:"OpenCode Integration Example"}),"\n",(0,i.jsx)(n.p,{children:"For integrating with OpenCode AI coding assistant:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'//! OpenCode plugin integration with Aeterna governance\n\nuse aeterna_adapters::opencode::{OpenCodeAdapter, McpTool};\nuse aeterna_tools::client::AeternaClient;\n\npub fn create_opencode_tools(client: AeternaClient) -> Vec<McpTool> {\n    let adapter = OpenCodeAdapter::new(client);\n    \n    vec![\n        // Memory tools\n        McpTool {\n            name: "memory_search".to_string(),\n            description: "Search past decisions and learnings".to_string(),\n            handler: adapter.memory_search_handler(),\n        },\n        McpTool {\n            name: "memory_add".to_string(),\n            description: "Store a new decision or learning".to_string(),\n            handler: adapter.memory_add_handler(),\n        },\n        \n        // Knowledge tools\n        McpTool {\n            name: "knowledge_query".to_string(),\n            description: "Search ADRs, patterns, and policies".to_string(),\n            handler: adapter.knowledge_query_handler(),\n        },\n        \n        // Policy tools\n        McpTool {\n            name: "check_constraint".to_string(),\n            description: "Check if an action is allowed by policy".to_string(),\n            handler: adapter.check_constraint_handler(),\n        },\n    ]\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Key takeaways for agent developers:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Register your agent"})," with appropriate capabilities using ",(0,i.jsx)(n.code,{children:"aeterna agent register"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configure authentication"})," via environment variables or config file"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Check constraints"})," before taking policy-sensitive actions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Handle errors gracefully"})," - especially permission denials"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Propose, don't edit"})," - use governance workflows for changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Request minimal capabilities"})," - principle of least privilege"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scope your operations"})," - don't search broader than needed"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For questions or support:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udcd6 Full API reference: ",(0,i.jsx)(n.code,{children:"docs/api/"})]}),"\n",(0,i.jsx)(n.li,{children:"\ud83d\udcac Discussions: GitHub Discussions"}),"\n",(0,i.jsx)(n.li,{children:"\ud83d\udc1b Issues: GitHub Issues"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);