"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9140],{8666(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"helm/quickstart-remote","title":"Remote Mode Deployment Guide","description":"Overview","source":"@site/docs/helm/quickstart-remote.md","sourceDirName":"helm","slug":"/helm/quickstart-remote","permalink":"/aeterna/docs/helm/quickstart-remote","draft":false,"unlisted":false,"editUrl":"https://github.com/kikokikok/aeterna/tree/main/website/docs/helm/quickstart-remote.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Hybrid Mode Deployment Guide","permalink":"/aeterna/docs/helm/quickstart-hybrid"},"next":{"title":"Aeterna CLI Quick Reference","permalink":"/aeterna/docs/guides/cli-quick-reference"}}');var s=t(4848),i=t(8453);const l={},o="Remote Mode Deployment Guide",a={},c=[{value:"Overview",id:"overview",level:2},{value:"When to Use Remote Mode",id:"when-to-use-remote-mode",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Step 1: Create Credentials Secret",id:"step-1-create-credentials-secret",level:2},{value:"Step 2: Create values-remote.yaml",id:"step-2-create-values-remoteyaml",level:2},{value:"Step 3: Install",id:"step-3-install",level:2},{value:"Step 4: Verify Connection",id:"step-4-verify-connection",level:2},{value:"Resource Usage",id:"resource-usage",level:2},{value:"Connection Requirements",id:"connection-requirements",level:2},{value:"Authentication Methods",id:"authentication-methods",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"remote-mode-deployment-guide",children:"Remote Mode Deployment Guide"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Remote mode allows you to run Aeterna as a thin client. This setup connects to a central Aeterna server for all its operations. You don't need local storage or local databases. It minimizes resource usage by offloading heavy lifting to the central cluster."}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-remote-mode",children:"When to Use Remote Mode"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cost-sensitive edge deployments."}),"\n",(0,s.jsx)(n.li,{children:"Environments with reliable network paths to a central server."}),"\n",(0,s.jsx)(n.li,{children:"Quick setup scenarios where you don't want to manage databases."}),"\n",(0,s.jsx)(n.li,{children:"Developer workstations using Docker Desktop or minikube."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[Local Cluster]                   [Central Cluster]  \nAeterna (remote) ------------\x3e   Aeterna (central)\n  \u2514\u2500\u2500 (no local storage)          \u251c\u2500\u2500 PostgreSQL\n                                  \u251c\u2500\u2500 Qdrant\n                                  \u251c\u2500\u2500 Dragonfly\n                                  \u2514\u2500\u2500 OPAL Stack\n"})}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A central Aeterna server must be deployed and accessible."}),"\n",(0,s.jsx)(n.li,{children:"Network connectivity (HTTPS) to the central server is required."}),"\n",(0,s.jsx)(n.li,{children:"You need an API key, OAuth2, or service account credentials."}),"\n",(0,s.jsx)(n.li,{children:"Kubernetes 1.25+ and Helm 3.10+ must be installed."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"step-1-create-credentials-secret",children:"Step 1: Create Credentials Secret"}),"\n",(0,s.jsx)(n.p,{children:"Run the following command to store your central server credentials:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl create secret generic aeterna-central-credentials \\\n  --from-literal=api-key='your-api-key-here'\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-2-create-values-remoteyaml",children:"Step 2: Create values-remote.yaml"}),"\n",(0,s.jsx)(n.p,{children:"Use this minimal configuration to enable remote mode:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'deploymentMode: remote\ncentral:\n  url: "https://aeterna-central.example.com"\n  auth: apiKey\n  existingSecret: "aeterna-central-credentials"\naeterna:\n  enabled: true\n  replicaCount: 1\npostgresql:\n  bundled: false\ncnpg:\n  enabled: false\ndragonfly:\n  enabled: false\nqdrant:\n  enabled: false\nopal:\n  enabled: false\ncache:\n  type: external\n  external:\n    enabled: false\n'})}),"\n",(0,s.jsx)(n.h2,{id:"step-3-install",children:"Step 3: Install"}),"\n",(0,s.jsx)(n.p,{children:"Install the chart with your remote values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"helm install aeterna-remote ./charts/aeterna -f values-remote.yaml\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-4-verify-connection",children:"Step 4: Verify Connection"}),"\n",(0,s.jsx)(n.p,{children:"Check the pod logs to ensure the connection is successful:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl logs -l app.kubernetes.io/name=aeterna\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can also test the health endpoint or verify connectivity from the central server's dashboard."}),"\n",(0,s.jsx)(n.h2,{id:"resource-usage",children:"Resource Usage"}),"\n",(0,s.jsx)(n.p,{children:"Remote mode has a very small footprint. Since it doesn't run its own databases or search engines, it only requires a single Aeterna pod. This makes it ideal for resource-constrained environments."}),"\n",(0,s.jsx)(n.h2,{id:"connection-requirements",children:"Connection Requirements"}),"\n",(0,s.jsx)(n.p,{children:"The remote cluster needs a stable connection to the central server. We recommend latency under 100ms for the best performance. If the central server becomes unreachable, the remote instance will enter a read-only or failover state depending on your configuration."}),"\n",(0,s.jsx)(n.h2,{id:"authentication-methods",children:"Authentication Methods"}),"\n",(0,s.jsx)(n.p,{children:"You can choose from several authentication methods:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"apiKey"}),": Uses a static key for simple setups."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"oauth2"}),": Connects through an OAuth2 provider for better security."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"serviceAccount"}),": Uses Kubernetes service account tokens for cluster-to-cluster auth."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Connection Refused"}),": Verify the central server URL and ensure no firewalls block the traffic."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Auth Failures"}),": Check if the secret contains the correct key and the central server recognizes it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timeout"}),": Network latency might be too high or the central server is overloaded."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Central Server Down"}),": Remote operations will fail until the central server is back online."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>l,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function l(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);