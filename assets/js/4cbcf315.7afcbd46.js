"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8062],{4725(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"governance/policy-model","title":"Policy Model Documentation","description":"This document describes the Aeterna governance system\'s policy model, Cedar integration, and role-based access control (RBAC) implementation.","source":"@site/docs/governance/policy-model.md","sourceDirName":"governance","slug":"/governance/policy-model","permalink":"/aeterna/docs/governance/policy-model","draft":false,"unlisted":false,"editUrl":"https://github.com/kikokikok/aeterna/tree/main/website/docs/governance/policy-model.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Memory-Knowledge Sync Specification","permalink":"/aeterna/docs/specs/memory-knowledge-sync"},"next":{"title":"Governance System API Reference","permalink":"/aeterna/docs/governance/api-reference"}}');var t=i(4848),s=i(8453);const l={},d="Policy Model Documentation",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Policy Structure",id:"policy-structure",level:2},{value:"Core Policy Definition",id:"core-policy-definition",level:3},{value:"Policy Properties",id:"policy-properties",level:3},{value:"Rule Definition",id:"rule-definition",level:2},{value:"Core Rule Structure",id:"core-rule-structure",level:3},{value:"Rule Properties",id:"rule-properties",level:3},{value:"Constraint Operators",id:"constraint-operators",level:2},{value:"MustExist",id:"mustexist",level:3},{value:"MustNotExist",id:"mustnotexist",level:3},{value:"MustUse",id:"mustuse",level:3},{value:"MustNotUse",id:"mustnotuse",level:3},{value:"MustMatch",id:"mustmatch",level:3},{value:"MustNotMatch",id:"mustnotmatch",level:3},{value:"Constraint Targets",id:"constraint-targets",level:2},{value:"Constraint Severity",id:"constraint-severity",level:2},{value:"Rule Types",id:"rule-types",level:2},{value:"Policy Mode",id:"policy-mode",level:2},{value:"Rule Merge Strategies",id:"rule-merge-strategies",level:2},{value:"Override",id:"override",level:3},{value:"Merge",id:"merge",level:3},{value:"Intersect",id:"intersect",level:3},{value:"Knowledge Layer Hierarchy",id:"knowledge-layer-hierarchy",level:2},{value:"Layer Precedence",id:"layer-precedence",level:3},{value:"Role-Based Access Control (RBAC)",id:"role-based-access-control-rbac",level:2},{value:"Role Hierarchy",id:"role-hierarchy",level:3},{value:"Role Permissions",id:"role-permissions",level:3},{value:"Cedar Integration",id:"cedar-integration",level:2},{value:"Cedar Schema Definition",id:"cedar-schema-definition",level:3},{value:"Authorization Rules",id:"authorization-rules",level:3},{value:"Cedar Authorizer Implementation",id:"cedar-authorizer-implementation",level:3},{value:"Alternative: Permit.io Integration",id:"alternative-permitio-integration",level:3},{value:"Policy Evaluation",id:"policy-evaluation",level:2},{value:"Evaluation Process",id:"evaluation-process",level:3},{value:"Context Structure",id:"context-structure",level:3},{value:"Validation Result",id:"validation-result",level:3},{value:"Drift Detection",id:"drift-detection",level:2},{value:"Drift Score Calculation",id:"drift-score-calculation",level:3},{value:"Policy Examples",id:"policy-examples",level:2},{value:"Security Baseline Policy",id:"security-baseline-policy",level:3},{value:"Dependency Allowlist Policy",id:"dependency-allowlist-policy",level:3},{value:"Code Pattern Enforcement Policy",id:"code-pattern-enforcement-policy",level:3},{value:"Governance Events",id:"governance-events",level:2},{value:"Event Types",id:"event-types",level:3},{value:"Event Structure",id:"event-structure",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Extensibility",id:"extensibility",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Policy Design",id:"policy-design",level:3},{value:"Rule Design",id:"rule-design",level:3},{value:"Cedar Integration",id:"cedar-integration-1",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"policy-model-documentation",children:"Policy Model Documentation"})}),"\n",(0,t.jsx)(n.p,{children:"This document describes the Aeterna governance system's policy model, Cedar integration, and role-based access control (RBAC) implementation."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The Aeterna governance system provides hierarchical policy management with rule-based validation, Cedar authorization integration, and multi-tenant role management. Policies flow down through organizational layers and can be merged, overridden, or intersected based on defined strategies."}),"\n",(0,t.jsx)(n.h2,{id:"policy-structure",children:"Policy Structure"}),"\n",(0,t.jsx)(n.h3,{id:"core-policy-definition",children:"Core Policy Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct Policy {\n    pub id: String,                                    // Unique policy identifier\n    pub name: String,                                  // Human-readable policy name\n    pub description: Option<String>,                    // Optional policy description\n    pub layer: KnowledgeLayer,                         // Organizational layer\n    pub mode: PolicyMode,                              // Enforcement mode\n    pub merge_strategy: RuleMergeStrategy,              // How to merge with parent policies\n    pub rules: Vec<PolicyRule>,                        // List of constraint rules\n    pub metadata: HashMap<String, serde_json::Value>   // Additional policy metadata\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"policy-properties",children:"Policy Properties"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Property"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"id"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"String"})}),(0,t.jsx)(n.td,{children:"Unique identifier for the policy"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"name"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"String"})}),(0,t.jsx)(n.td,{children:"Human-readable policy name"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"description"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Option<String>"})}),(0,t.jsx)(n.td,{children:"Optional detailed description"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"layer"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"KnowledgeLayer"})}),(0,t.jsx)(n.td,{children:"Organizational layer (Company, Org, Team, Project)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"mode"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PolicyMode"})}),(0,t.jsx)(n.td,{children:"Optional or Mandatory enforcement"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"merge_strategy"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RuleMergeStrategy"})}),(0,t.jsx)(n.td,{children:"How to combine with parent policies"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"rules"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Vec<PolicyRule>"})}),(0,t.jsx)(n.td,{children:"List of constraint rules"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"metadata"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"HashMap<String, serde_json::Value>"})}),(0,t.jsx)(n.td,{children:"Additional metadata for versioning, embeddings, etc."})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"rule-definition",children:"Rule Definition"}),"\n",(0,t.jsx)(n.h3,{id:"core-rule-structure",children:"Core Rule Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct PolicyRule {\n    pub id: String,                                    // Unique rule identifier\n    pub rule_type: RuleType,                            // Allow or Deny\n    pub target: ConstraintTarget,                       // What the rule applies to\n    pub operator: ConstraintOperator,                  // How to evaluate the constraint\n    pub value: serde_json::Value,                      // Expected value or pattern\n    pub severity: ConstraintSeverity,                   // Violation severity level\n    pub message: String                                 // Human-readable violation message\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"rule-properties",children:"Rule Properties"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Property"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"id"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"String"})}),(0,t.jsx)(n.td,{children:"Unique identifier for the rule"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"rule_type"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RuleType"})}),(0,t.jsx)(n.td,{children:"Allow or Deny rule type"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"target"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ConstraintTarget"})}),(0,t.jsx)(n.td,{children:"Target of the constraint (File, Code, Dependency, Import, Config)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"operator"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ConstraintOperator"})}),(0,t.jsx)(n.td,{children:"Evaluation operator"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"value"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"serde_json::Value"})}),(0,t.jsx)(n.td,{children:"Expected value or pattern"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"severity"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ConstraintSeverity"})}),(0,t.jsx)(n.td,{children:"Severity level for violations"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"message"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"String"})}),(0,t.jsx)(n.td,{children:"Human-readable violation message"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"constraint-operators",children:"Constraint Operators"}),"\n",(0,t.jsx)(n.h3,{id:"mustexist",children:"MustExist"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Requires a target to exist in context"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Ensuring required files or configurations are present"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),": ",(0,t.jsx)(n.code,{children:"MustExist"})," on ",(0,t.jsx)(n.code,{children:'"README.md"'})," file"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mustnotexist",children:"MustNotExist"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Requires a target to be absent from context"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Preventing forbidden files or configurations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),": ",(0,t.jsx)(n.code,{children:"MustNotExist"})," on ",(0,t.jsx)(n.code,{children:'"secrets.txt"'})," file"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mustuse",children:"MustUse"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Requires a specific value to be present or used"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Enforcing dependency usage, requiring specific imports"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),": ",(0,t.jsx)(n.code,{children:"MustUse"})," ",(0,t.jsx)(n.code,{children:'"log4j"'})," dependency"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mustnotuse",children:"MustNotUse"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Prohibits a specific value from being used"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Banning deprecated or unsafe dependencies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),": ",(0,t.jsx)(n.code,{children:"MustNotUse"})," ",(0,t.jsx)(n.code,{children:'"unsafe-lib"'})," dependency"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mustmatch",children:"MustMatch"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Requires content to match a regex pattern"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Enforcing code style, naming conventions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),": ",(0,t.jsx)(n.code,{children:"MustMatch"})," ",(0,t.jsx)(n.code,{children:'"^# ADR"'})," for ADR headers"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mustnotmatch",children:"MustNotMatch"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Prohibits content from matching a regex pattern"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Preventing anti-patterns in code"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),": ",(0,t.jsx)(n.code,{children:"MustNotMatch"})," ",(0,t.jsx)(n.code,{children:'"console\\.log"'})," in production code"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"constraint-targets",children:"Constraint Targets"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Target"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Context Key"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"File"})}),(0,t.jsx)(n.td,{children:"File path validation"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"path"'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Code"})}),(0,t.jsx)(n.td,{children:"Source code content validation"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"content"'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Dependency"})}),(0,t.jsx)(n.td,{children:"Package dependency validation"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"dependencies"'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Import"})}),(0,t.jsx)(n.td,{children:"Module import validation"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"imports"'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Config"})}),(0,t.jsx)(n.td,{children:"Configuration file validation"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"config"'})})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"constraint-severity",children:"Constraint Severity"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Severity"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Impact"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Info"})}),(0,t.jsx)(n.td,{children:"Informational violation"}),(0,t.jsx)(n.td,{children:"0.1 drift score"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Warn"})}),(0,t.jsx)(n.td,{children:"Warning violation"}),(0,t.jsx)(n.td,{children:"0.5 drift score"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Block"})}),(0,t.jsx)(n.td,{children:"Blocking violation"}),(0,t.jsx)(n.td,{children:"1.0 drift score"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"rule-types",children:"Rule Types"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Evaluation Logic"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Allow"})}),(0,t.jsx)(n.td,{children:"Condition must be met"}),(0,t.jsx)(n.td,{children:"Violation when condition is NOT met"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Deny"})}),(0,t.jsx)(n.td,{children:"Condition must not be met"}),(0,t.jsx)(n.td,{children:"Violation when condition IS met"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"policy-mode",children:"Policy Mode"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Mode"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Behavior"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Optional"})}),(0,t.jsx)(n.td,{children:"Policy is advisory"}),(0,t.jsx)(n.td,{children:"Can be overridden by lower layers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Mandatory"})}),(0,t.jsx)(n.td,{children:"Policy is required"}),(0,t.jsx)(n.td,{children:"Cannot be overridden (except with Override strategy)"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"rule-merge-strategies",children:"Rule Merge Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"override",children:"Override"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Behavior"}),": Completely replaces existing policy rules"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": When lower layers need to completely replace parent policies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Precedence"}),": Lower layer policies take precedence"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"merge",children:"Merge"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Behavior"}),": Combines rules from both policies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": When adding new rules without removing existing ones"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),": Adds unique rules, merges metadata"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"intersect",children:"Intersect"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Behavior"}),": Keeps only rules present in both policies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": When policies should be more restrictive"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),": Removes rules not present in incoming policy"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"knowledge-layer-hierarchy",children:"Knowledge Layer Hierarchy"}),"\n",(0,t.jsx)(n.p,{children:"Policies flow down through organizational layers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Company (highest precedence)\n    \u2193\nOrganization\n    \u2193\nTeam\n    \u2193\nProject (lowest precedence)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"layer-precedence",children:"Layer Precedence"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Company policies have the highest precedence"}),"\n",(0,t.jsx)(n.li,{children:"Project policies have the lowest precedence"}),"\n",(0,t.jsx)(n.li,{children:"Lower layers can override higher layers using appropriate merge strategies"}),"\n",(0,t.jsx)(n.li,{children:"Mandatory policies from higher layers cannot be overridden (except with Override strategy)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"role-based-access-control-rbac",children:"Role-Based Access Control (RBAC)"}),"\n",(0,t.jsx)(n.h3,{id:"role-hierarchy",children:"Role Hierarchy"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Role"}),(0,t.jsx)(n.th,{children:"Precedence"}),(0,t.jsx)(n.th,{children:"Display Name"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Admin"})}),(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"Admin"}),(0,t.jsx)(n.td,{children:"Full system access"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Architect"})}),(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"Architect"}),(0,t.jsx)(n.td,{children:"System architecture and policy design"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"TechLead"})}),(0,t.jsx)(n.td,{children:"2"}),(0,t.jsx)(n.td,{children:"Tech Lead"}),(0,t.jsx)(n.td,{children:"Technical leadership and team management"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Developer"})}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"Developer"}),(0,t.jsx)(n.td,{children:"Standard development access"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Agent"})}),(0,t.jsx)(n.td,{children:"0"}),(0,t.jsx)(n.td,{children:"Agent"}),(0,t.jsx)(n.td,{children:"AI agent with delegated permissions"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"role-permissions",children:"Role Permissions"}),"\n",(0,t.jsx)(n.p,{children:"Roles determine access levels for different operations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Admin"}),": Can manage all aspects of the system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Architect"}),": Can design and modify policies, manage knowledge repository"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TechLead"}),": Can manage team resources, enforce policies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Developer"}),": Standard development and knowledge access"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Agent"}),": Delegated permissions based on user context"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"cedar-integration",children:"Cedar Integration"}),"\n",(0,t.jsx)(n.h3,{id:"cedar-schema-definition",children:"Cedar Schema Definition"}),"\n",(0,t.jsx)(n.p,{children:"The system uses Cedar for authorization with the following schema:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cedar",children:"entity type User;\n\nentity type Unit {\n    parent: Unit,\n    tenant_id: String\n};\n\nentity type Role {\n    name: String\n};\n\naction ViewKnowledge, EditKnowledge, DeleteKnowledge, AdministerUnit;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"authorization-rules",children:"Authorization Rules"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cedar",children:'// Allow users to view knowledge if they are members of the unit (or parent units)\npermit (\n    principal,\n    action == Action::"ViewKnowledge",\n    resource\n)\nwhen {\n    principal in resource.members\n};\n\n// Allow Unit Admins to administer the unit\npermit (\n    principal,\n    action == Action::"AdministerUnit",\n    resource\n)\nwhen {\n    principal has role && principal.role == Role::"UnitAdmin"\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"cedar-authorizer-implementation",children:"Cedar Authorizer Implementation"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"CedarAuthorizer"})," provides:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Permission checking for users and agents"}),"\n",(0,t.jsx)(n.li,{children:"Delegation support for agent actions"}),"\n",(0,t.jsx)(n.li,{children:"Integration with the Cedar policy engine"}),"\n",(0,t.jsx)(n.li,{children:"Entity and policy management"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"alternative-permitio-integration",children:"Alternative: Permit.io Integration"}),"\n",(0,t.jsx)(n.p,{children:"For external authorization, the system supports Permit.io:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"RESTful API integration"}),"\n",(0,t.jsx)(n.li,{children:"Role management"}),"\n",(0,t.jsx)(n.li,{children:"Permission checking"}),"\n",(0,t.jsx)(n.li,{children:"Multi-tenant support"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"policy-evaluation",children:"Policy Evaluation"}),"\n",(0,t.jsx)(n.h3,{id:"evaluation-process",children:"Evaluation Process"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Policy Resolution"}),": Gather policies from all applicable layers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Policy Merging"}),": Apply merge strategies to combine policies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rule Evaluation"}),": Evaluate each rule against the context"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Violation Collection"}),": Collect all rule violations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result Generation"}),": Return validation result with violations"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"context-structure",children:"Context Structure"}),"\n",(0,t.jsx)(n.p,{children:"Policies are evaluated against a context containing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "path": "file/path/to/validate",\n    "content": "file or code content",\n    "dependencies": ["dep1", "dep2"],\n    "imports": ["module1", "module2"],\n    "config": { "key": "value" },\n    "unitId": "organizational-unit-id",\n    "projectId": "project-identifier"\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"validation-result",children:"Validation Result"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct ValidationResult {\n    pub is_valid: bool,                              // Overall validation status\n    pub violations: Vec<PolicyViolation>              // List of violations\n}\n\npub struct PolicyViolation {\n    pub rule_id: String,                             // Rule that was violated\n    pub policy_id: String,                           // Policy containing the rule\n    pub severity: ConstraintSeverity,                 // Violation severity\n    pub message: String,                              // Violation message\n    pub context: HashMap<String, serde_json::Value>   // Evaluation context\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"drift-detection",children:"Drift Detection"}),"\n",(0,t.jsx)(n.p,{children:"The system provides drift detection capabilities:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Semantic similarity analysis using embeddings"}),"\n",(0,t.jsx)(n.li,{children:"LLM-based drift analysis"}),"\n",(0,t.jsx)(n.li,{children:"Policy version checking"}),"\n",(0,t.jsx)(n.li,{children:"Continuous monitoring"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"drift-score-calculation",children:"Drift Score Calculation"}),"\n",(0,t.jsx)(n.p,{children:"Drift scores are calculated based on violation severity:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Block"}),": 1.0 points"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Warn"}),": 0.5 points"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Info"}),": 0.1 points"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Final drift score is the minimum of the total score and 1.0."}),"\n",(0,t.jsx)(n.h2,{id:"policy-examples",children:"Policy Examples"}),"\n",(0,t.jsx)(n.h3,{id:"security-baseline-policy",children:"Security Baseline Policy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let security_policy = Policy {\n    id: "security-baseline".to_string(),\n    name: "Security Baseline".to_string(),\n    description: Some("Core security requirements".to_string()),\n    layer: KnowledgeLayer::Company,\n    mode: PolicyMode::Mandatory,\n    merge_strategy: RuleMergeStrategy::Merge,\n    rules: vec![\n        PolicyRule {\n            id: "no-unsafe-deps".to_string(),\n            rule_type: RuleType::Deny,\n            target: ConstraintTarget::Dependency,\n            operator: ConstraintOperator::MustNotUse,\n            value: serde_json::json!("unsafe-lib"),\n            severity: ConstraintSeverity::Block,\n            message: "unsafe-lib is prohibited for security reasons".to_string(),\n        },\n        PolicyRule {\n            id: "require-readme".to_string(),\n            rule_type: RuleType::Allow,\n            target: ConstraintTarget::File,\n            operator: ConstraintOperator::MustExist,\n            value: serde_json::json!("README.md"),\n            severity: ConstraintSeverity::Warn,\n            message: "Project must have a README.md file".to_string(),\n        }\n    ],\n    metadata: HashMap::new(),\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"dependency-allowlist-policy",children:"Dependency Allowlist Policy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let dependency_policy = Policy {\n    id: "dependency-allowlist".to_string(),\n    name: "Approved Dependencies".to_string(),\n    description: Some("Only approved dependencies may be used".to_string()),\n    layer: KnowledgeLayer::Org,\n    mode: PolicyMode::Mandatory,\n    merge_strategy: RuleMergeStrategy::Intersect,\n    rules: vec![\n        PolicyRule {\n            id: "approved-deps".to_string(),\n            rule_type: RuleType::Allow,\n            target: ConstraintTarget::Dependency,\n            operator: ConstraintOperator::MustUse,\n            value: serde_json::json!(["serde", "tokio", "reqwest"]),\n            severity: ConstraintSeverity::Block,\n            message: "Only approved dependencies are allowed".to_string(),\n        }\n    ],\n    metadata: HashMap::new(),\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"code-pattern-enforcement-policy",children:"Code Pattern Enforcement Policy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let code_pattern_policy = Policy {\n    id: "code-patterns".to_string(),\n    name: "Code Pattern Enforcement".to_string(),\n    description: Some("Enforces coding standards and patterns".to_string()),\n    layer: KnowledgeLayer::Team,\n    mode: PolicyMode::Optional,\n    merge_strategy: RuleMergeStrategy::Merge,\n    rules: vec![\n        PolicyRule {\n            id: "rust-error-handling".to_string(),\n            rule_type: RuleType::Allow,\n            target: ConstraintTarget::Code,\n            operator: ConstraintOperator::MustMatch,\n            value: serde_json::json!(r"Result<.*, .*>|Option<.*>"),\n            severity: ConstraintSeverity::Warn,\n            message: "Use Result or Option for error handling".to_string(),\n        },\n        PolicyRule {\n            id: "no-debug-prints".to_string(),\n            rule_type: RuleType::Deny,\n            target: ConstraintTarget::Code,\n            operator: ConstraintOperator::MustNotMatch,\n            value: serde_json::json!(r"println!|dbg!|debug_print!"),\n            severity: ConstraintSeverity::Info,\n            message: "Remove debug print statements".to_string(),\n        }\n    ],\n    metadata: HashMap::new(),\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"governance-events",children:"Governance Events"}),"\n",(0,t.jsx)(n.p,{children:"The system emits governance events for auditing and monitoring:"}),"\n",(0,t.jsx)(n.h3,{id:"event-types",children:"Event Types"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Event"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"UnitCreated"})}),(0,t.jsx)(n.td,{children:"New organizational unit created"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"UnitUpdated"})}),(0,t.jsx)(n.td,{children:"Organizational unit updated"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"UnitDeleted"})}),(0,t.jsx)(n.td,{children:"Organizational unit deleted"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RoleAssigned"})}),(0,t.jsx)(n.td,{children:"Role assigned to user"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RoleRemoved"})}),(0,t.jsx)(n.td,{children:"Role removed from user"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PolicyUpdated"})}),(0,t.jsx)(n.td,{children:"Policy created or updated"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PolicyDeleted"})}),(0,t.jsx)(n.td,{children:"Policy deleted"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"DriftDetected"})}),(0,t.jsx)(n.td,{children:"Drift detected in project"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"event-structure",children:"Event Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub enum GovernanceEvent {\n    UnitCreated { unit_id: String, unit_type: UnitType, tenant_id: TenantId, parent_id: Option<String>, timestamp: i64 },\n    RoleAssigned { user_id: UserId, unit_id: String, role: Role, tenant_id: TenantId, timestamp: i64 },\n    PolicyUpdated { policy_id: String, layer: KnowledgeLayer, tenant_id: TenantId, timestamp: i64 },\n    DriftDetected { project_id: String, tenant_id: TenantId, drift_score: f32, timestamp: i64 },\n    // ... other event types\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,t.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Policy evaluation is optimized for hierarchical resolution"}),"\n",(0,t.jsx)(n.li,{children:"Caching is used for frequently accessed policies"}),"\n",(0,t.jsx)(n.li,{children:"Batch evaluation is supported for multiple validations"}),"\n",(0,t.jsx)(n.li,{children:"Embedding-based analysis is optional and configurable"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"extensibility",children:"Extensibility"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Custom constraint operators can be added via trait implementations"}),"\n",(0,t.jsxs)(n.li,{children:["New authorization providers can implement the ",(0,t.jsx)(n.code,{children:"AuthorizationService"})," trait"]}),"\n",(0,t.jsxs)(n.li,{children:["Policy merge strategies are extensible through the ",(0,t.jsx)(n.code,{children:"RuleMergeStrategy"})," enum"]}),"\n",(0,t.jsxs)(n.li,{children:["Event publishers can be customised via the ",(0,t.jsx)(n.code,{children:"EventPublisher"})," trait"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Policy validation errors are captured in ",(0,t.jsx)(n.code,{children:"ValidationResult"})]}),"\n",(0,t.jsxs)(n.li,{children:["Authorization errors are type-safe through the ",(0,t.jsx)(n.code,{children:"AuthorizationService"})," trait"]}),"\n",(0,t.jsx)(n.li,{children:"Drift analysis failures are logged but don't prevent operation"}),"\n",(0,t.jsx)(n.li,{children:"Schema validation errors are caught early in the policy loading process"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"policy-design",children:"Policy Design"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Start with company-level mandatory policies"})," for core requirements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use org-level policies"})," for department-specific constraints"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Apply team-level policies"})," for coding standards and patterns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reserve project-level policies"})," for project-specific requirements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use appropriate merge strategies"})," to balance control and flexibility"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"rule-design",children:"Rule Design"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prefer Allow rules"})," for positive requirements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Deny rules"})," for clear prohibitions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Set appropriate severity levels"})," based on impact"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Write clear, actionable violation messages"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use specific targets"})," to minimize evaluation overhead"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"cedar-integration-1",children:"Cedar Integration"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Define clear entity hierarchies"})," in the schema"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use role-based access"})," for scalable authorization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implement delegation"})," for agent permissions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate policies"})," before deployment"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitor authorization failures"})," for security insights"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This policy model provides a comprehensive framework for governing AI agent behavior, ensuring compliance with organizational standards while maintaining flexibility for diverse use cases."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>d});var r=i(6540);const t={},s=r.createContext(t);function l(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);