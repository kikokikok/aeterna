"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2665],{1078(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"specs/memory-knowledge-sync","title":"Memory-Knowledge Sync Specification","description":"This document specifies the Sync Bridge component: the mechanism that keeps Memory and Knowledge systems aligned through pointer architecture and delta synchronization.","source":"@site/docs/specs/04-memory-knowledge-sync.md","sourceDirName":"specs","slug":"/specs/memory-knowledge-sync","permalink":"/aeterna/docs/specs/memory-knowledge-sync","draft":false,"unlisted":false,"editUrl":"https://github.com/kikokikok/aeterna/tree/main/website/docs/specs/04-memory-knowledge-sync.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Memory-Knowledge Sync Specification","status":"draft","version":"0.1.0","created":"2025-01-07T00:00:00.000Z","authors":["AI Systems Architecture Team"],"related":["02-memory-system.md","03-knowledge-repository.md","05-adapter-architecture.md"]},"sidebar":"docs","previous":{"title":"Knowledge Repository Specification","permalink":"/aeterna/docs/specs/knowledge-repository"},"next":{"title":"Policy Model Documentation","permalink":"/aeterna/docs/governance/policy-model"}}');var r=t(4848),i=t(8453);const o={title:"Memory-Knowledge Sync Specification",status:"draft",version:"0.1.0",created:new Date("2025-01-07T00:00:00.000Z"),authors:["AI Systems Architecture Team"],related:["02-memory-system.md","03-knowledge-repository.md","05-adapter-architecture.md"]},a="Memory-Knowledge Sync Specification",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Design Goals",id:"design-goals",level:3},{value:"Pointer Architecture",id:"pointer-architecture",level:2},{value:"The Pointer Pattern",id:"the-pointer-pattern",level:3},{value:"Pointer Schema",id:"pointer-schema",level:3},{value:"Content Generation",id:"content-generation",level:3},{value:"Layer Mapping",id:"layer-mapping",level:3},{value:"Sync State Management",id:"sync-state-management",level:2},{value:"Sync State Schema",id:"sync-state-schema",level:3},{value:"State Persistence",id:"state-persistence",level:3},{value:"Default Storage Locations",id:"default-storage-locations",level:3},{value:"Delta Detection",id:"delta-detection",level:2},{value:"Change Detection Algorithm",id:"change-detection-algorithm",level:3},{value:"Content Hashing",id:"content-hashing",level:3},{value:"Sync Operations",id:"sync-operations",level:2},{value:"Full Sync",id:"full-sync",level:3},{value:"Sync Algorithm",id:"sync-algorithm",level:3},{value:"Incremental Sync",id:"incremental-sync",level:3},{value:"Single Item Sync",id:"single-item-sync",level:3},{value:"Conflict Resolution",id:"conflict-resolution",level:2},{value:"Conflict Types",id:"conflict-types",level:3},{value:"Resolution Strategy",id:"resolution-strategy",level:3},{value:"Conflict Detection",id:"conflict-detection",level:3},{value:"Sync Triggers",id:"sync-triggers",level:2},{value:"Trigger Types",id:"trigger-types",level:3},{value:"Trigger Evaluation",id:"trigger-evaluation",level:3},{value:"Session-Based Sync",id:"session-based-sync",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Error Types",id:"error-types",level:3},{value:"Retry Strategy",id:"retry-strategy",level:3},{value:"Failure Recovery",id:"failure-recovery",level:3},{value:"Observability",id:"observability",level:2},{value:"Metrics",id:"metrics",level:3},{value:"Logging",id:"logging",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"memory-knowledge-sync-specification",children:"Memory-Knowledge Sync Specification"})}),"\n",(0,r.jsx)(n.p,{children:"This document specifies the Sync Bridge component: the mechanism that keeps Memory and Knowledge systems aligned through pointer architecture and delta synchronization."}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pointer-architecture",children:"Pointer Architecture"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#sync-state-management",children:"Sync State Management"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#delta-detection",children:"Delta Detection"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#sync-operations",children:"Sync Operations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#conflict-resolution",children:"Conflict Resolution"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#sync-triggers",children:"Sync Triggers"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#error-handling",children:"Error Handling"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Sync Bridge maintains consistency between Memory and Knowledge systems:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                       SYNC BRIDGE                                \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502                   Sync Coordinator                       \u2502    \u2502\n\u2502  \u2502  \u2022 Orchestrates sync operations                          \u2502    \u2502\n\u2502  \u2502  \u2022 Manages sync state persistence                        \u2502    \u2502\n\u2502  \u2502  \u2022 Handles conflict resolution                           \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                              \u2502                                   \u2502\n\u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502         \u2502                    \u2502                    \u2502              \u2502\n\u2502         \u25bc                    \u25bc                    \u25bc              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502  \u2502   Delta     \u2502     \u2502  Pointer    \u2502     \u2502   State     \u2502        \u2502\n\u2502  \u2502  Detector   \u2502     \u2502  Manager    \u2502     \u2502  Persister  \u2502        \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                                         \u2502\n         \u25bc                                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 KNOWLEDGE REPO  \u2502                     \u2502  MEMORY SYSTEM  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"design-goals",children:"Design Goals"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Goal"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Efficiency"})}),(0,r.jsx)(n.td,{children:"Only sync changed items (delta sync)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Consistency"})}),(0,r.jsx)(n.td,{children:"Memory pointers always reference valid knowledge"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Resilience"})}),(0,r.jsx)(n.td,{children:"Recover from partial failures"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Observability"})}),(0,r.jsx)(n.td,{children:"Clear audit trail of sync operations"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pointer-architecture",children:"Pointer Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"the-pointer-pattern",children:"The Pointer Pattern"}),"\n",(0,r.jsxs)(n.p,{children:["Memory stores ",(0,r.jsx)(n.strong,{children:"lightweight pointers"})," to knowledge items:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                                  \u2502\n\u2502  MEMORY ENTRY (Pointer)              KNOWLEDGE ITEM (Source)    \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500             \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500     \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 id: mem_ptr_001     \u2502             \u2502 id: adr-042         \u2502    \u2502\n\u2502  \u2502                     \u2502             \u2502                     \u2502    \u2502\n\u2502  \u2502 content:            \u2502             \u2502 title: Database     \u2502    \u2502\n\u2502  \u2502   "Use PostgreSQL   \u2502             \u2502        Selection    \u2502    \u2502\n\u2502  \u2502    per ADR-042"     \u2502             \u2502                     \u2502    \u2502\n\u2502  \u2502                     \u2502             \u2502 content:            \u2502    \u2502\n\u2502  \u2502 metadata:           \u2502             \u2502   ## Context        \u2502    \u2502\n\u2502  \u2502   knowledgePointer: \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   We need to...     \u2502    \u2502\n\u2502  \u2502     sourceType: adr \u2502             \u2502   (500+ lines)      \u2502    \u2502\n\u2502  \u2502     sourceId: adr042\u2502             \u2502                     \u2502    \u2502\n\u2502  \u2502     contentHash:    \u2502             \u2502 constraints:        \u2502    \u2502\n\u2502  \u2502       sha256:abc... \u2502             \u2502   - must_use:       \u2502    \u2502\n\u2502  \u2502     syncedAt:       \u2502             \u2502       postgresql    \u2502    \u2502\n\u2502  \u2502       2025-01-07    \u2502             \u2502                     \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                                  \u2502\n\u2502  Memory is LEAN                      Knowledge is COMPLETE      \u2502\n\u2502  (fits in context)                   (full audit trail)         \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pointer-schema",children:"Pointer Schema"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"/**\n * Pointer from memory entry to knowledge item.\n */\ninterface KnowledgePointer {\n  /** Type of knowledge item */\n  sourceType: KnowledgeType;\n  \n  /** ID of knowledge item */\n  sourceId: string;\n  \n  /** SHA-256 hash of content at sync time */\n  contentHash: string;\n  \n  /** When this pointer was last synced */\n  syncedAt: string;\n  \n  /** Knowledge layer */\n  sourceLayer: KnowledgeLayer;\n  \n  /** Whether source still exists */\n  isOrphaned: boolean;\n}\n\n/**\n * Memory entry with knowledge pointer.\n */\ninterface KnowledgePointerMemory {\n  /** Memory ID */\n  id: string;\n  \n  /** Summary content (from knowledge) */\n  content: string;\n  \n  /** Memory layer */\n  layer: MemoryLayer;\n  \n  /** Layer identifiers */\n  identifiers: LayerIdentifiers;\n  \n  /** Pointer metadata */\n  metadata: {\n    /** Marker that this is a knowledge pointer */\n    type: 'knowledge_pointer';\n    \n    /** The pointer itself */\n    knowledgePointer: KnowledgePointer;\n    \n    /** Tags from knowledge item */\n    tags?: string[];\n  };\n  \n  /** Timestamps */\n  createdAt: string;\n  updatedAt: string;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"content-generation",children:"Content Generation"}),"\n",(0,r.jsx)(n.p,{children:"When syncing knowledge to memory, generate searchable content:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function generatePointerContent(knowledge: KnowledgeItem): string {\n  const parts: string[] = [];\n  \n  // Title\n  parts.push(knowledge.title);\n  \n  // Summary\n  parts.push(knowledge.summary);\n  \n  // Type indicator\n  parts.push(`[${knowledge.type.toUpperCase()}]`);\n  \n  // Key constraints (if any blocking)\n  const blockingConstraints = knowledge.constraints\n    .filter(c => c.severity === 'block')\n    .slice(0, 3);\n  \n  if (blockingConstraints.length > 0) {\n    parts.push('Constraints:');\n    for (const c of blockingConstraints) {\n      parts.push(`- ${c.message || formatConstraint(c)}`);\n    }\n  }\n  \n  // Reference\n  parts.push(`(${knowledge.id})`);\n  \n  return parts.join('\\n');\n}\n\nfunction formatConstraint(c: Constraint): string {\n  return `${c.operator}: ${c.pattern} [${c.target}]`;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"layer-mapping",children:"Layer Mapping"}),"\n",(0,r.jsx)(n.p,{children:"Knowledge layers map to memory layers for pointer storage:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Knowledge Layer"}),(0,r.jsx)(n.th,{children:"Default Memory Layer"}),(0,r.jsx)(n.th,{children:"Rationale"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"company"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"company"})}),(0,r.jsx)(n.td,{children:"1:1 mapping"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"org"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"org"})}),(0,r.jsx)(n.td,{children:"1:1 mapping"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"team"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"team"})}),(0,r.jsx)(n.td,{children:"1:1 mapping"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"project"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"project"})}),(0,r.jsx)(n.td,{children:"1:1 mapping"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"sync-state-management",children:"Sync State Management"}),"\n",(0,r.jsx)(n.h3,{id:"sync-state-schema",children:"Sync State Schema"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"/**\n * Persistent state of sync operations.\n */\ninterface SyncState {\n  /** Sync state version */\n  version: '1.0';\n  \n  /** Last successful sync timestamp */\n  lastSyncAt: string | null;\n  \n  /** Last knowledge commit synced */\n  lastKnowledgeCommit: string | null;\n  \n  /** Hash map: knowledge ID \u2192 content hash at last sync */\n  knowledgeHashes: Record<string, string>;\n  \n  /** Hash map: memory pointer ID \u2192 knowledge ID */\n  pointerMapping: Record<string, string>;\n  \n  /** Items that failed to sync */\n  failedItems: SyncFailure[];\n  \n  /** Sync statistics */\n  stats: SyncStats;\n}\n\ninterface SyncFailure {\n  /** Knowledge item ID */\n  knowledgeId: string;\n  \n  /** Error message */\n  error: string;\n  \n  /** Failure timestamp */\n  failedAt: string;\n  \n  /** Retry count */\n  retryCount: number;\n}\n\ninterface SyncStats {\n  /** Total successful syncs */\n  totalSyncs: number;\n  \n  /** Total items synced */\n  totalItemsSynced: number;\n  \n  /** Total conflicts resolved */\n  totalConflicts: number;\n  \n  /** Average sync duration (ms) */\n  avgSyncDurationMs: number;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"state-persistence",children:"State Persistence"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface SyncStatePersister {\n  /** Load sync state (or return default if none) */\n  load(): Promise<SyncState>;\n  \n  /** Save sync state */\n  save(state: SyncState): Promise<void>;\n  \n  /** Create checkpoint for rollback */\n  checkpoint(): Promise<string>;\n  \n  /** Rollback to checkpoint */\n  rollback(checkpointId: string): Promise<void>;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"default-storage-locations",children:"Default Storage Locations"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Environment"}),(0,r.jsx)(n.th,{children:"Storage Location"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Local development"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"~/.config/memory-knowledge/sync-state.json"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"CI/CD"}),(0,r.jsx)(n.td,{children:"Environment variable or secrets manager"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Production"}),(0,r.jsx)(n.td,{children:"Database or object storage"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"delta-detection",children:"Delta Detection"}),"\n",(0,r.jsx)(n.h3,{id:"change-detection-algorithm",children:"Change Detection Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface DeltaResult {\n  /** New items in knowledge not in memory */\n  added: KnowledgeItem[];\n  \n  /** Items whose content hash changed */\n  updated: KnowledgeItem[];\n  \n  /** Items in memory but not in knowledge */\n  deleted: string[];\n  \n  /** Items unchanged */\n  unchanged: string[];\n}\n\nasync function detectDelta(\n  knowledgeManifest: KnowledgeManifest,\n  syncState: SyncState\n): Promise<DeltaResult> {\n  const delta: DeltaResult = {\n    added: [],\n    updated: [],\n    deleted: [],\n    unchanged: []\n  };\n  \n  const currentKnowledgeIds = new Set(Object.keys(knowledgeManifest.items));\n  const previousKnowledgeIds = new Set(Object.keys(syncState.knowledgeHashes));\n  \n  // Find added items\n  for (const [id, entry] of Object.entries(knowledgeManifest.items)) {\n    if (!previousKnowledgeIds.has(id)) {\n      const item = await loadKnowledgeItem(id);\n      delta.added.push(item);\n    }\n  }\n  \n  // Find updated items\n  for (const [id, entry] of Object.entries(knowledgeManifest.items)) {\n    if (previousKnowledgeIds.has(id)) {\n      const previousHash = syncState.knowledgeHashes[id];\n      if (previousHash !== entry.contentHash) {\n        const item = await loadKnowledgeItem(id);\n        delta.updated.push(item);\n      } else {\n        delta.unchanged.push(id);\n      }\n    }\n  }\n  \n  // Find deleted items\n  for (const id of previousKnowledgeIds) {\n    if (!currentKnowledgeIds.has(id)) {\n      delta.deleted.push(id);\n    }\n  }\n  \n  return delta;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"content-hashing",children:"Content Hashing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { createHash } from 'crypto';\n\nfunction computeContentHash(content: string): string {\n  return createHash('sha256')\n    .update(content, 'utf8')\n    .digest('hex');\n}\n\nfunction computeKnowledgeHash(item: KnowledgeItem): string {\n  // Hash includes content + constraints (structural changes)\n  const hashInput = JSON.stringify({\n    content: item.content,\n    constraints: item.constraints,\n    status: item.status\n  });\n  return computeContentHash(hashInput);\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"sync-operations",children:"Sync Operations"}),"\n",(0,r.jsx)(n.h3,{id:"full-sync",children:"Full Sync"}),"\n",(0,r.jsx)(n.p,{children:"Synchronize all knowledge items to memory:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface FullSyncInput {\n  /** Force re-sync even if unchanged */\n  force?: boolean;\n  \n  /** Layer identifiers for scoping */\n  identifiers: LayerIdentifiers;\n  \n  /** Only sync specific knowledge types */\n  types?: KnowledgeType[];\n  \n  /** Only sync specific layers */\n  layers?: KnowledgeLayer[];\n}\n\ninterface FullSyncOutput {\n  /** Sync result */\n  result: SyncResult;\n  \n  /** New sync state */\n  newState: SyncState;\n}\n\ninterface SyncResult {\n  /** Whether sync completed successfully */\n  success: boolean;\n  \n  /** Items added to memory */\n  added: number;\n  \n  /** Items updated in memory */\n  updated: number;\n  \n  /** Items removed from memory */\n  deleted: number;\n  \n  /** Items unchanged */\n  unchanged: number;\n  \n  /** Failures */\n  failures: SyncFailure[];\n  \n  /** Sync duration in milliseconds */\n  durationMs: number;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sync-algorithm",children:"Sync Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"async function executeFullSync(\n  input: FullSyncInput,\n  knowledgeRepo: KnowledgeRepository,\n  memoryManager: MemoryManager,\n  syncState: SyncState\n): Promise<FullSyncOutput> {\n  const startTime = Date.now();\n  const result: SyncResult = {\n    success: true,\n    added: 0,\n    updated: 0,\n    deleted: 0,\n    unchanged: 0,\n    failures: [],\n    durationMs: 0\n  };\n  \n  // 1. Create checkpoint for rollback\n  const checkpoint = await syncStatePersister.checkpoint();\n  \n  try {\n    // 2. Get knowledge manifest\n    const manifest = await knowledgeRepo.getManifest();\n    \n    // 3. Filter by types/layers if specified\n    const filteredItems = filterManifest(manifest, input.types, input.layers);\n    \n    // 4. Detect delta\n    const delta = input.force\n      ? { added: Object.values(filteredItems), updated: [], deleted: [], unchanged: [] }\n      : await detectDelta(filteredItems, syncState);\n    \n    // 5. Process additions\n    for (const item of delta.added) {\n      try {\n        const memoryId = await createPointerMemory(item, input.identifiers, memoryManager);\n        syncState.knowledgeHashes[item.id] = item.contentHash;\n        syncState.pointerMapping[memoryId] = item.id;\n        result.added++;\n      } catch (error) {\n        result.failures.push({\n          knowledgeId: item.id,\n          error: error.message,\n          failedAt: new Date().toISOString(),\n          retryCount: 0\n        });\n      }\n    }\n    \n    // 6. Process updates\n    for (const item of delta.updated) {\n      try {\n        const memoryId = findPointerMemoryId(item.id, syncState);\n        await updatePointerMemory(memoryId, item, memoryManager);\n        syncState.knowledgeHashes[item.id] = item.contentHash;\n        result.updated++;\n      } catch (error) {\n        result.failures.push({\n          knowledgeId: item.id,\n          error: error.message,\n          failedAt: new Date().toISOString(),\n          retryCount: 0\n        });\n      }\n    }\n    \n    // 7. Process deletions\n    for (const knowledgeId of delta.deleted) {\n      try {\n        const memoryId = findPointerMemoryId(knowledgeId, syncState);\n        await markPointerOrphaned(memoryId, memoryManager);\n        delete syncState.knowledgeHashes[knowledgeId];\n        result.deleted++;\n      } catch (error) {\n        result.failures.push({\n          knowledgeId,\n          error: error.message,\n          failedAt: new Date().toISOString(),\n          retryCount: 0\n        });\n      }\n    }\n    \n    result.unchanged = delta.unchanged.length;\n    \n    // 8. Update sync state\n    syncState.lastSyncAt = new Date().toISOString();\n    syncState.lastKnowledgeCommit = manifest.commitHash;\n    syncState.failedItems = result.failures;\n    syncState.stats.totalSyncs++;\n    syncState.stats.totalItemsSynced += result.added + result.updated;\n    \n    await syncStatePersister.save(syncState);\n    \n    result.success = result.failures.length === 0;\n    \n  } catch (error) {\n    // Rollback on catastrophic failure\n    await syncStatePersister.rollback(checkpoint);\n    throw error;\n  }\n  \n  result.durationMs = Date.now() - startTime;\n  \n  return { result, newState: syncState };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"incremental-sync",children:"Incremental Sync"}),"\n",(0,r.jsx)(n.p,{children:"Sync only items changed since last sync:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface IncrementalSyncInput {\n  /** Layer identifiers */\n  identifiers: LayerIdentifiers;\n  \n  /** Maximum items to sync (for rate limiting) */\n  maxItems?: number;\n}\n\nasync function executeIncrementalSync(\n  input: IncrementalSyncInput,\n  knowledgeRepo: KnowledgeRepository,\n  memoryManager: MemoryManager,\n  syncState: SyncState\n): Promise<FullSyncOutput> {\n  // Similar to full sync but:\n  // 1. Uses lastKnowledgeCommit to fetch only new commits\n  // 2. Processes changes incrementally\n  // 3. Respects maxItems limit\n  \n  const commits = await knowledgeRepo.getCommitsSince(syncState.lastKnowledgeCommit);\n  \n  const affectedItems = new Set<string>();\n  for (const commit of commits) {\n    for (const itemId of commit.affectedItems) {\n      affectedItems.add(itemId);\n    }\n  }\n  \n  // Process only affected items (up to maxItems)\n  const itemsToProcess = Array.from(affectedItems).slice(0, input.maxItems ?? Infinity);\n  \n  // ... rest similar to full sync\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"single-item-sync",children:"Single Item Sync"}),"\n",(0,r.jsx)(n.p,{children:"Sync a single knowledge item immediately:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface SingleItemSyncInput {\n  /** Knowledge item ID */\n  knowledgeId: string;\n  \n  /** Layer identifiers */\n  identifiers: LayerIdentifiers;\n}\n\nasync function syncSingleItem(\n  input: SingleItemSyncInput,\n  knowledgeRepo: KnowledgeRepository,\n  memoryManager: MemoryManager,\n  syncState: SyncState\n): Promise<{ success: boolean; memoryId?: string; error?: string }> {\n  const item = await knowledgeRepo.getItem(input.knowledgeId);\n  \n  if (!item) {\n    // Item deleted - mark pointer orphaned\n    const memoryId = findPointerMemoryId(input.knowledgeId, syncState);\n    if (memoryId) {\n      await markPointerOrphaned(memoryId, memoryManager);\n      delete syncState.knowledgeHashes[input.knowledgeId];\n      delete syncState.pointerMapping[memoryId];\n    }\n    return { success: true };\n  }\n  \n  const existingMemoryId = findPointerMemoryId(input.knowledgeId, syncState);\n  \n  if (existingMemoryId) {\n    // Update existing\n    await updatePointerMemory(existingMemoryId, item, memoryManager);\n    syncState.knowledgeHashes[item.id] = item.contentHash;\n    return { success: true, memoryId: existingMemoryId };\n  } else {\n    // Create new\n    const memoryId = await createPointerMemory(item, input.identifiers, memoryManager);\n    syncState.knowledgeHashes[item.id] = item.contentHash;\n    syncState.pointerMapping[memoryId] = item.id;\n    return { success: true, memoryId };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"conflict-resolution",children:"Conflict Resolution"}),"\n",(0,r.jsx)(n.h3,{id:"conflict-types",children:"Conflict Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type ConflictType =\n  | 'hash_mismatch'      // Memory hash differs from knowledge\n  | 'orphaned_pointer'   // Memory points to deleted knowledge\n  | 'duplicate_pointer'  // Multiple memories point to same knowledge\n  | 'layer_mismatch'     // Memory layer doesn't match knowledge layer\n  | 'status_change';     // Knowledge status changed (deprecated/superseded)\n\ninterface Conflict {\n  /** Conflict type */\n  type: ConflictType;\n  \n  /** Memory entry involved */\n  memoryId: string;\n  \n  /** Knowledge item involved */\n  knowledgeId: string;\n  \n  /** Details */\n  details: Record<string, unknown>;\n  \n  /** Suggested resolution */\n  suggestedResolution: ConflictResolution;\n}\n\ntype ConflictResolution =\n  | 'update_memory'      // Update memory from knowledge\n  | 'delete_memory'      // Remove orphaned memory\n  | 'keep_memory'        // Keep memory, ignore knowledge change\n  | 'merge'              // Merge changes\n  | 'manual';            // Requires manual intervention\n"})}),"\n",(0,r.jsx)(n.h3,{id:"resolution-strategy",children:"Resolution Strategy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface ConflictResolutionConfig {\n  /** Default resolution per conflict type */\n  defaults: Record<ConflictType, ConflictResolution>;\n  \n  /** Custom resolver function */\n  customResolver?: (conflict: Conflict) => ConflictResolution;\n}\n\nconst defaultResolutionConfig: ConflictResolutionConfig = {\n  defaults: {\n    hash_mismatch: 'update_memory',      // Knowledge is authoritative\n    orphaned_pointer: 'delete_memory',   // Clean up stale pointers\n    duplicate_pointer: 'delete_memory',  // Keep newest, delete duplicates\n    layer_mismatch: 'update_memory',     // Correct layer assignment\n    status_change: 'update_memory'       // Reflect status in memory\n  }\n};\n\nasync function resolveConflict(\n  conflict: Conflict,\n  config: ConflictResolutionConfig,\n  memoryManager: MemoryManager,\n  knowledgeRepo: KnowledgeRepository\n): Promise<void> {\n  const resolution = config.customResolver?.(conflict) \n    ?? config.defaults[conflict.type];\n  \n  switch (resolution) {\n    case 'update_memory':\n      const item = await knowledgeRepo.getItem(conflict.knowledgeId);\n      if (item) {\n        await updatePointerMemory(conflict.memoryId, item, memoryManager);\n      }\n      break;\n      \n    case 'delete_memory':\n      await memoryManager.delete({ id: conflict.memoryId });\n      break;\n      \n    case 'keep_memory':\n      // No action - log for audit\n      break;\n      \n    case 'merge':\n      // Complex merge logic - implementation specific\n      break;\n      \n    case 'manual':\n      throw new Error(`Conflict requires manual resolution: ${conflict.type}`);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"conflict-detection",children:"Conflict Detection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"async function detectConflicts(\n  syncState: SyncState,\n  knowledgeRepo: KnowledgeRepository,\n  memoryManager: MemoryManager\n): Promise<Conflict[]> {\n  const conflicts: Conflict[] = [];\n  \n  // Check each pointer for conflicts\n  for (const [memoryId, knowledgeId] of Object.entries(syncState.pointerMapping)) {\n    const memory = await memoryManager.get({ id: memoryId });\n    const knowledge = await knowledgeRepo.getItem(knowledgeId);\n    \n    if (!memory) {\n      // Memory was deleted externally\n      conflicts.push({\n        type: 'orphaned_pointer',\n        memoryId,\n        knowledgeId,\n        details: { reason: 'memory_deleted' },\n        suggestedResolution: 'delete_memory'\n      });\n      continue;\n    }\n    \n    if (!knowledge) {\n      // Knowledge was deleted\n      conflicts.push({\n        type: 'orphaned_pointer',\n        memoryId,\n        knowledgeId,\n        details: { reason: 'knowledge_deleted' },\n        suggestedResolution: 'delete_memory'\n      });\n      continue;\n    }\n    \n    const pointer = memory.metadata.knowledgePointer as KnowledgePointer;\n    \n    // Check hash mismatch\n    if (pointer.contentHash !== knowledge.contentHash) {\n      conflicts.push({\n        type: 'hash_mismatch',\n        memoryId,\n        knowledgeId,\n        details: {\n          memoryHash: pointer.contentHash,\n          knowledgeHash: knowledge.contentHash\n        },\n        suggestedResolution: 'update_memory'\n      });\n    }\n    \n    // Check status change\n    if (knowledge.status === 'deprecated' || knowledge.status === 'superseded') {\n      conflicts.push({\n        type: 'status_change',\n        memoryId,\n        knowledgeId,\n        details: { newStatus: knowledge.status },\n        suggestedResolution: 'update_memory'\n      });\n    }\n  }\n  \n  return conflicts;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"sync-triggers",children:"Sync Triggers"}),"\n",(0,r.jsx)(n.h3,{id:"trigger-types",children:"Trigger Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type SyncTrigger =\n  | 'manual'           // User-initiated\n  | 'scheduled'        // Cron/interval based\n  | 'event'            // On knowledge change\n  | 'session_start'    // On agent session start\n  | 'threshold';       // After N sessions or staleness\n\ninterface SyncTriggerConfig {\n  /** Enable automatic sync */\n  autoSync: boolean;\n  \n  /** Scheduled sync interval (e.g., \"1h\", \"6h\", \"1d\") */\n  scheduleInterval?: string;\n  \n  /** Sync on every N sessions */\n  sessionThreshold?: number;\n  \n  /** Sync if state older than duration */\n  stalenessThreshold?: string;\n  \n  /** Sync on knowledge commit webhook */\n  webhookEnabled?: boolean;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"trigger-evaluation",children:"Trigger Evaluation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function shouldTriggerSync(\n  config: SyncTriggerConfig,\n  syncState: SyncState,\n  context: { sessionCount: number }\n): { shouldSync: boolean; reason: SyncTrigger } {\n  // Check staleness\n  if (config.stalenessThreshold && syncState.lastSyncAt) {\n    const lastSync = new Date(syncState.lastSyncAt);\n    const threshold = parseDuration(config.stalenessThreshold);\n    if (Date.now() - lastSync.getTime() > threshold) {\n      return { shouldSync: true, reason: 'threshold' };\n    }\n  }\n  \n  // Check session threshold\n  if (config.sessionThreshold) {\n    const sessionsSinceSync = context.sessionCount - (syncState.stats.totalSyncs ?? 0);\n    if (sessionsSinceSync >= config.sessionThreshold) {\n      return { shouldSync: true, reason: 'threshold' };\n    }\n  }\n  \n  return { shouldSync: false, reason: 'manual' };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"session-based-sync",children:"Session-Based Sync"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface SessionSyncConfig {\n  /** Sync at session start */\n  syncOnStart: boolean;\n  \n  /** Sync at session end */\n  syncOnEnd: boolean;\n  \n  /** Only sync if stale */\n  stalenessCheck: boolean;\n  \n  /** Staleness threshold */\n  stalenessThreshold: string;\n}\n\nasync function handleSessionStart(\n  config: SessionSyncConfig,\n  syncState: SyncState,\n  identifiers: LayerIdentifiers\n): Promise<void> {\n  if (!config.syncOnStart) return;\n  \n  if (config.stalenessCheck) {\n    const isStale = checkStaleness(syncState, config.stalenessThreshold);\n    if (!isStale) return;\n  }\n  \n  await executeIncrementalSync({ identifiers }, knowledgeRepo, memoryManager, syncState);\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.h3,{id:"error-types",children:"Error Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type SyncErrorCode =\n  | 'KNOWLEDGE_UNAVAILABLE'  // Cannot reach knowledge repo\n  | 'MEMORY_UNAVAILABLE'     // Cannot reach memory system\n  | 'STATE_CORRUPTED'        // Sync state is invalid\n  | 'CHECKPOINT_FAILED'      // Cannot create checkpoint\n  | 'ROLLBACK_FAILED'        // Cannot rollback\n  | 'PARTIAL_FAILURE'        // Some items failed to sync\n  | 'CONFLICT_UNRESOLVED'    // Manual conflict resolution needed\n  | 'TIMEOUT';               // Sync operation timed out\n\ninterface SyncError {\n  code: SyncErrorCode;\n  message: string;\n  details?: Record<string, unknown>;\n  retryable: boolean;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"retry-strategy",children:"Retry Strategy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface SyncRetryConfig {\n  /** Maximum retry attempts */\n  maxAttempts: number;\n  \n  /** Initial delay (ms) */\n  initialDelayMs: number;\n  \n  /** Maximum delay (ms) */\n  maxDelayMs: number;\n  \n  /** Backoff multiplier */\n  backoffMultiplier: number;\n  \n  /** Error codes to retry */\n  retryableCodes: SyncErrorCode[];\n}\n\nconst defaultSyncRetryConfig: SyncRetryConfig = {\n  maxAttempts: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 30000,\n  backoffMultiplier: 2,\n  retryableCodes: [\n    'KNOWLEDGE_UNAVAILABLE',\n    'MEMORY_UNAVAILABLE',\n    'TIMEOUT'\n  ]\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"failure-recovery",children:"Failure Recovery"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"async function recoverFromFailure(\n  syncState: SyncState,\n  lastGoodCheckpoint: string\n): Promise<void> {\n  // 1. Rollback sync state\n  await syncStatePersister.rollback(lastGoodCheckpoint);\n  \n  // 2. Retry failed items\n  const retryableFailures = syncState.failedItems.filter(\n    f => f.retryCount < defaultSyncRetryConfig.maxAttempts\n  );\n  \n  for (const failure of retryableFailures) {\n    try {\n      await syncSingleItem({\n        knowledgeId: failure.knowledgeId,\n        identifiers: getCurrentIdentifiers()\n      }, knowledgeRepo, memoryManager, syncState);\n      \n      // Remove from failures\n      syncState.failedItems = syncState.failedItems.filter(\n        f => f.knowledgeId !== failure.knowledgeId\n      );\n    } catch (error) {\n      failure.retryCount++;\n      failure.failedAt = new Date().toISOString();\n      failure.error = error.message;\n    }\n  }\n  \n  await syncStatePersister.save(syncState);\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"observability",children:"Observability"}),"\n",(0,r.jsx)(n.h3,{id:"metrics",children:"Metrics"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Metric"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync.operations.total"})}),(0,r.jsx)(n.td,{children:"Counter"}),(0,r.jsx)(n.td,{children:"Total sync operations"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync.operations.duration"})}),(0,r.jsx)(n.td,{children:"Histogram"}),(0,r.jsx)(n.td,{children:"Sync duration (ms)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync.items.added"})}),(0,r.jsx)(n.td,{children:"Counter"}),(0,r.jsx)(n.td,{children:"Items added to memory"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync.items.updated"})}),(0,r.jsx)(n.td,{children:"Counter"}),(0,r.jsx)(n.td,{children:"Items updated in memory"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync.items.deleted"})}),(0,r.jsx)(n.td,{children:"Counter"}),(0,r.jsx)(n.td,{children:"Items deleted from memory"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync.conflicts.total"})}),(0,r.jsx)(n.td,{children:"Counter"}),(0,r.jsx)(n.td,{children:"Total conflicts detected"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync.failures.total"})}),(0,r.jsx)(n.td,{children:"Counter"}),(0,r.jsx)(n.td,{children:"Failed sync operations"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync.state.age"})}),(0,r.jsx)(n.td,{children:"Gauge"}),(0,r.jsx)(n.td,{children:"Time since last sync (s)"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface SyncLogEntry {\n  timestamp: string;\n  level: 'info' | 'warn' | 'error';\n  operation: string;\n  trigger: SyncTrigger;\n  duration_ms: number;\n  items_processed: number;\n  failures: number;\n  conflicts: number;\n  details?: Record<string, unknown>;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Next"}),": ",(0,r.jsx)(n.a,{href:"/aeterna/docs/specs/adapter-architecture",children:"05-adapter-architecture.md"})," - Adapter Architecture Specification"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);