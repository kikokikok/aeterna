"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8033],{2082(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"specs/adapter-architecture","title":"Adapter Architecture Specification","description":"This document specifies the two-layer adapter architecture: Provider Adapters (storage backends) and Ecosystem Adapters (AI agent frameworks).","source":"@site/docs/specs/05-adapter-architecture.md","sourceDirName":"specs","slug":"/specs/adapter-architecture","permalink":"/aeterna/docs/specs/adapter-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/kikokikok/aeterna/tree/main/website/docs/specs/05-adapter-architecture.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Adapter Architecture Specification","status":"draft","version":"0.1.0","created":"2025-01-07T00:00:00.000Z","authors":["AI Systems Architecture Team"],"related":["00-overview.md","02-memory-system.md","06-tool-interface.md"]},"sidebar":"docs","previous":{"title":"Configuration Specification","permalink":"/aeterna/docs/specs/configuration"},"next":{"title":"09 - Migration & Data Portability","permalink":"/aeterna/docs/specs/migration"}}');var i=t(4848),s=t(8453);const o={title:"Adapter Architecture Specification",status:"draft",version:"0.1.0",created:new Date("2025-01-07T00:00:00.000Z"),authors:["AI Systems Architecture Team"],related:["00-overview.md","02-memory-system.md","06-tool-interface.md"]},a="Adapter Architecture Specification",d={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Design Goals",id:"design-goals",level:3},{value:"Provider Adapters",id:"provider-adapters",level:2},{value:"Provider Adapter Interface",id:"provider-adapter-interface",level:3},{value:"Provider Adapter Examples",id:"provider-adapter-examples",level:3},{value:"Mem0 Provider Adapter",id:"mem0-provider-adapter",level:4},{value:"Chroma Provider Adapter",id:"chroma-provider-adapter",level:4},{value:"Ecosystem Adapters",id:"ecosystem-adapters",level:2},{value:"Ecosystem Adapter Interface",id:"ecosystem-adapter-interface",level:3},{value:"Ecosystem Adapter Examples",id:"ecosystem-adapter-examples",level:3},{value:"LangChain Adapter",id:"langchain-adapter",level:4},{value:"OpenCode Adapter",id:"opencode-adapter",level:4},{value:"Adapter Registration",id:"adapter-registration",level:2},{value:"Registry Interface",id:"registry-interface",level:3},{value:"Registration Example",id:"registration-example",level:3},{value:"Adapter Package Convention",id:"adapter-package-convention",level:3},{value:"Adapter Lifecycle",id:"adapter-lifecycle",level:2},{value:"Lifecycle Diagram",id:"lifecycle-diagram",level:3},{value:"State Management",id:"state-management",level:3},{value:"Testing Adapters",id:"testing-adapters",level:2},{value:"Test Interface",id:"test-interface",level:3},{value:"Mock Adapter for Testing",id:"mock-adapter-for-testing",level:3},{value:"Reference Implementations",id:"reference-implementations",level:2},{value:"Provider Adapters",id:"provider-adapters-1",level:3},{value:"Ecosystem Adapters",id:"ecosystem-adapters-1",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"adapter-architecture-specification",children:"Adapter Architecture Specification"})}),"\n",(0,i.jsxs)(n.p,{children:["This document specifies the two-layer adapter architecture: ",(0,i.jsx)(n.strong,{children:"Provider Adapters"})," (storage backends) and ",(0,i.jsx)(n.strong,{children:"Ecosystem Adapters"})," (AI agent frameworks)."]}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#provider-adapters",children:"Provider Adapters"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#ecosystem-adapters",children:"Ecosystem Adapters"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#adapter-registration",children:"Adapter Registration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#adapter-lifecycle",children:"Adapter Lifecycle"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#testing-adapters",children:"Testing Adapters"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#reference-implementations",children:"Reference Implementations"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The adapter architecture enables pluggable integration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                                  \u2502\n\u2502                     AI AGENT ECOSYSTEMS                          \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502  \u2502 LangChain \u2502 \u2502  AutoGen  \u2502 \u2502  CrewAI   \u2502 \u2502 OpenCode  \u2502        \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2502        \u2502             \u2502             \u2502             \u2502               \u2502\n\u2502        \u2502    Ecosystem Adapter Interface          \u2502               \u2502\n\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2502                             \u2502                                    \u2502\n\u2502                             \u25bc                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502                                                          \u2502    \u2502\n\u2502  \u2502              MEMORY-KNOWLEDGE CORE                       \u2502    \u2502\n\u2502  \u2502                                                          \u2502    \u2502\n\u2502  \u2502  \u2022 Unified API                                           \u2502    \u2502\n\u2502  \u2502  \u2022 Layer resolution                                      \u2502    \u2502\n\u2502  \u2502  \u2022 Constraint evaluation                                 \u2502    \u2502\n\u2502  \u2502  \u2022 Sync orchestration                                    \u2502    \u2502\n\u2502  \u2502                                                          \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                             \u2502                                    \u2502\n\u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502        \u2502             \u2502             \u2502             \u2502               \u2502\n\u2502        \u2502    Provider Adapter Interface           \u2502               \u2502\n\u2502        \u25bc             \u25bc             \u25bc             \u25bc               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502  \u2502   Mem0    \u2502 \u2502   Letta   \u2502 \u2502  Chroma   \u2502 \u2502 Pinecone  \u2502        \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2502                                                                  \u2502\n\u2502                     STORAGE PROVIDERS                            \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(n.h3,{id:"design-goals",children:"Design Goals"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Goal"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Pluggability"})}),(0,i.jsx)(n.td,{children:"Add new providers/ecosystems without core changes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Isolation"})}),(0,i.jsx)(n.td,{children:"Adapter failures don't crash the core"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Testability"})}),(0,i.jsx)(n.td,{children:"Mock adapters for testing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Discoverability"})}),(0,i.jsx)(n.td,{children:"Auto-detect available adapters"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Versioning"})}),(0,i.jsx)(n.td,{children:"Adapters specify compatible core versions"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"provider-adapters",children:"Provider Adapters"}),"\n",(0,i.jsx)(n.h3,{id:"provider-adapter-interface",children:"Provider Adapter Interface"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"/**\n * Interface for memory storage providers.\n * Implement this to add support for a new storage backend.\n */\ninterface MemoryProviderAdapter {\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // METADATA\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Provider identifier (e.g., \"mem0\", \"letta\", \"chroma\") */\n  readonly id: string;\n  \n  /** Human-readable name */\n  readonly name: string;\n  \n  /** Provider version */\n  readonly version: string;\n  \n  /** Compatible core versions (semver range) */\n  readonly coreCompatibility: string;\n  \n  /** Provider capabilities */\n  readonly capabilities: ProviderCapabilities;\n  \n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // LIFECYCLE\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Initialize provider with configuration */\n  initialize(config: ProviderConfig): Promise<void>;\n  \n  /** Graceful shutdown */\n  shutdown(): Promise<void>;\n  \n  /** Health check */\n  healthCheck(): Promise<HealthCheckResult>;\n  \n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // CORE OPERATIONS\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Add a memory entry */\n  add(input: AddMemoryInput): Promise<AddMemoryOutput>;\n  \n  /** Search memories semantically */\n  search(input: SearchMemoryInput): Promise<SearchMemoryOutput>;\n  \n  /** Get a specific memory */\n  get(input: GetMemoryInput): Promise<GetMemoryOutput>;\n  \n  /** Update a memory */\n  update(input: UpdateMemoryInput): Promise<UpdateMemoryOutput>;\n  \n  /** Delete a memory */\n  delete(input: DeleteMemoryInput): Promise<DeleteMemoryOutput>;\n  \n  /** List memories with pagination */\n  list(input: ListMemoriesInput): Promise<ListMemoriesOutput>;\n  \n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // EMBEDDING OPERATIONS\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Generate embedding for content */\n  generateEmbedding(content: string): Promise<number[]>;\n  \n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // OPTIONAL BULK OPERATIONS\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Bulk add memories (optional) */\n  bulkAdd?(inputs: AddMemoryInput[]): Promise<AddMemoryOutput[]>;\n  \n  /** Bulk delete memories (optional) */\n  bulkDelete?(ids: string[]): Promise<BulkDeleteResult>;\n  \n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // OPTIONAL ADVANCED OPERATIONS\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Export all memories (optional) */\n  export?(): Promise<ExportResult>;\n  \n  /** Import memories (optional) */\n  import?(data: ImportData): Promise<ImportResult>;\n  \n  /** Clear all memories in a layer (optional) */\n  clearLayer?(layer: MemoryLayer, identifiers: LayerIdentifiers): Promise<void>;\n}\n\ninterface ProviderCapabilities {\n  /** Supports vector similarity search */\n  vectorSearch: boolean;\n  \n  /** Supports metadata filtering */\n  metadataFiltering: boolean;\n  \n  /** Supports bulk operations */\n  bulkOperations: boolean;\n  \n  /** Supports export/import */\n  dataPortability: boolean;\n  \n  /** Supports real-time updates */\n  realTimeUpdates: boolean;\n  \n  /** Maximum content length (characters) */\n  maxContentLength: number;\n  \n  /** Maximum metadata size (bytes) */\n  maxMetadataSize: number;\n  \n  /** Embedding dimensions */\n  embeddingDimensions: number;\n  \n  /** Supported distance metrics */\n  distanceMetrics: ('cosine' | 'euclidean' | 'dot_product')[];\n}\n\ninterface ProviderConfig {\n  /** API endpoint URL */\n  endpoint?: string;\n  \n  /** API key or token */\n  apiKey?: string;\n  \n  /** Connection timeout (ms) */\n  timeout?: number;\n  \n  /** Retry configuration */\n  retry?: RetryConfig;\n  \n  /** Provider-specific options */\n  options?: Record<string, unknown>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"provider-adapter-examples",children:"Provider Adapter Examples"}),"\n",(0,i.jsx)(n.h4,{id:"mem0-provider-adapter",children:"Mem0 Provider Adapter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class Mem0ProviderAdapter implements MemoryProviderAdapter {\n  readonly id = 'mem0';\n  readonly name = 'Mem0';\n  readonly version = '1.0.0';\n  readonly coreCompatibility = '>=0.1.0';\n  \n  readonly capabilities: ProviderCapabilities = {\n    vectorSearch: true,\n    metadataFiltering: true,\n    bulkOperations: true,\n    dataPortability: true,\n    realTimeUpdates: false,\n    maxContentLength: 100000,\n    maxMetadataSize: 65536,\n    embeddingDimensions: 1536,\n    distanceMetrics: ['cosine']\n  };\n  \n  private client: Mem0Client | null = null;\n  \n  async initialize(config: ProviderConfig): Promise<void> {\n    this.client = new Mem0Client({\n      apiKey: config.apiKey,\n      baseUrl: config.endpoint ?? 'https://api.mem0.ai',\n      timeout: config.timeout ?? 30000\n    });\n    \n    // Verify connection\n    await this.healthCheck();\n  }\n  \n  async shutdown(): Promise<void> {\n    this.client = null;\n  }\n  \n  async healthCheck(): Promise<HealthCheckResult> {\n    const start = Date.now();\n    try {\n      await this.client!.ping();\n      return {\n        status: 'healthy',\n        latencyMs: Date.now() - start\n      };\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        latencyMs: Date.now() - start,\n        error: error.message\n      };\n    }\n  }\n  \n  async add(input: AddMemoryInput): Promise<AddMemoryOutput> {\n    const response = await this.client!.add({\n      messages: [{ role: 'user', content: input.content }],\n      user_id: this.buildUserId(input.layer, input.identifiers),\n      metadata: input.metadata\n    });\n    \n    return {\n      memory: this.mapToMemoryEntry(response, input),\n      embeddingGenerated: true\n    };\n  }\n  \n  async search(input: SearchMemoryInput): Promise<SearchMemoryOutput> {\n    const results: MemorySearchResult[] = [];\n    \n    for (const layer of input.layers ?? ['user']) {\n      const userId = this.buildUserId(layer, input.identifiers);\n      \n      const response = await this.client!.search({\n        query: input.query,\n        user_id: userId,\n        limit: input.limit ?? 10,\n        threshold: input.threshold ?? 0.7\n      });\n      \n      for (const item of response.results) {\n        results.push({\n          memory: this.mapToMemoryEntry(item, { layer, identifiers: input.identifiers }),\n          score: item.score,\n          layer\n        });\n      }\n    }\n    \n    return {\n      results: this.sortByPrecedence(results),\n      totalCount: results.length,\n      searchedLayers: input.layers ?? ['user']\n    };\n  }\n  \n  // ... other method implementations\n  \n  private buildUserId(layer: MemoryLayer, ids: LayerIdentifiers): string {\n    switch (layer) {\n      case 'agent': return `agent:${ids.agentId}:${ids.userId}`;\n      case 'user': return `user:${ids.userId}`;\n      case 'session': return `session:${ids.userId}:${ids.sessionId}`;\n      case 'project': return `project:${ids.projectId}`;\n      case 'team': return `team:${ids.teamId}`;\n      case 'org': return `org:${ids.orgId}`;\n      case 'company': return `company:${ids.companyId}`;\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"chroma-provider-adapter",children:"Chroma Provider Adapter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class ChromaProviderAdapter implements MemoryProviderAdapter {\n  readonly id = 'chroma';\n  readonly name = 'Chroma';\n  readonly version = '1.0.0';\n  readonly coreCompatibility = '>=0.1.0';\n  \n  readonly capabilities: ProviderCapabilities = {\n    vectorSearch: true,\n    metadataFiltering: true,\n    bulkOperations: true,\n    dataPortability: true,\n    realTimeUpdates: false,\n    maxContentLength: 50000,\n    maxMetadataSize: 32768,\n    embeddingDimensions: 384, // default, configurable\n    distanceMetrics: ['cosine', 'euclidean', 'dot_product']\n  };\n  \n  private client: ChromaClient | null = null;\n  private collections: Map<string, Collection> = new Map();\n  \n  async initialize(config: ProviderConfig): Promise<void> {\n    this.client = new ChromaClient({\n      path: config.endpoint ?? 'http://localhost:8000'\n    });\n  }\n  \n  async add(input: AddMemoryInput): Promise<AddMemoryOutput> {\n    const collection = await this.getOrCreateCollection(input.layer, input.identifiers);\n    \n    const id = crypto.randomUUID();\n    await collection.add({\n      ids: [id],\n      documents: [input.content],\n      metadatas: [{ ...input.metadata, layer: input.layer }]\n    });\n    \n    return {\n      memory: {\n        id,\n        content: input.content,\n        layer: input.layer,\n        identifiers: input.identifiers,\n        metadata: input.metadata ?? {},\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      },\n      embeddingGenerated: true\n    };\n  }\n  \n  async search(input: SearchMemoryInput): Promise<SearchMemoryOutput> {\n    const results: MemorySearchResult[] = [];\n    \n    for (const layer of input.layers ?? ['user']) {\n      try {\n        const collection = await this.getCollection(layer, input.identifiers);\n        if (!collection) continue;\n        \n        const response = await collection.query({\n          queryTexts: [input.query],\n          nResults: input.limit ?? 10,\n          where: input.filter ? this.buildWhereClause(input.filter) : undefined\n        });\n        \n        for (let i = 0; i < response.ids[0].length; i++) {\n          results.push({\n            memory: {\n              id: response.ids[0][i],\n              content: response.documents[0][i],\n              layer,\n              identifiers: input.identifiers,\n              metadata: response.metadatas[0][i] as MemoryMetadata,\n              createdAt: '', // Chroma doesn't store timestamps by default\n              updatedAt: ''\n            },\n            score: 1 - (response.distances?.[0][i] ?? 0), // Convert distance to similarity\n            layer\n          });\n        }\n      } catch (error) {\n        // Collection doesn't exist - skip\n      }\n    }\n    \n    return {\n      results: this.sortByPrecedence(results),\n      totalCount: results.length,\n      searchedLayers: input.layers ?? ['user']\n    };\n  }\n  \n  private async getOrCreateCollection(\n    layer: MemoryLayer, \n    ids: LayerIdentifiers\n  ): Promise<Collection> {\n    const name = this.buildCollectionName(layer, ids);\n    \n    if (!this.collections.has(name)) {\n      const collection = await this.client!.getOrCreateCollection({ name });\n      this.collections.set(name, collection);\n    }\n    \n    return this.collections.get(name)!;\n  }\n  \n  private buildCollectionName(layer: MemoryLayer, ids: LayerIdentifiers): string {\n    // Chroma collection names must be 3-63 chars, alphanumeric with underscores\n    const parts = [layer];\n    switch (layer) {\n      case 'agent': parts.push(ids.agentId!, ids.userId!); break;\n      case 'user': parts.push(ids.userId!); break;\n      case 'session': parts.push(ids.userId!, ids.sessionId!); break;\n      case 'project': parts.push(ids.projectId!); break;\n      case 'team': parts.push(ids.teamId!); break;\n      case 'org': parts.push(ids.orgId!); break;\n      case 'company': parts.push(ids.companyId!); break;\n    }\n    return parts.join('_').substring(0, 63);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"ecosystem-adapters",children:"Ecosystem Adapters"}),"\n",(0,i.jsx)(n.h3,{id:"ecosystem-adapter-interface",children:"Ecosystem Adapter Interface"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'/**\n * Interface for AI agent framework integration.\n * Implement this to add support for a new ecosystem.\n */\ninterface EcosystemAdapter {\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // METADATA\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Ecosystem identifier (e.g., "langchain", "autogen", "opencode") */\n  readonly id: string;\n  \n  /** Human-readable name */\n  readonly name: string;\n  \n  /** Adapter version */\n  readonly version: string;\n  \n  /** Compatible ecosystem versions (semver range) */\n  readonly ecosystemCompatibility: string;\n  \n  /** Compatible core versions (semver range) */\n  readonly coreCompatibility: string;\n  \n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // LIFECYCLE\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Initialize adapter with core instance */\n  initialize(core: MemoryKnowledgeCore, config: EcosystemConfig): Promise<void>;\n  \n  /** Graceful shutdown */\n  shutdown(): Promise<void>;\n  \n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // TOOL GENERATION\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Generate ecosystem-native tools for memory operations */\n  getMemoryTools(): EcosystemTool[];\n  \n  /** Generate ecosystem-native tools for knowledge operations */\n  getKnowledgeTools(): EcosystemTool[];\n  \n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // CONTEXT INJECTION\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Get context to inject at session start */\n  getSessionContext(identifiers: LayerIdentifiers): Promise<SessionContext>;\n  \n  /** Get relevant memories for current context */\n  getRelevantMemories(query: string, identifiers: LayerIdentifiers): Promise<MemoryEntry[]>;\n  \n  /** Get applicable constraints for current context */\n  getActiveConstraints(identifiers: LayerIdentifiers): Promise<Constraint[]>;\n  \n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // EVENT HOOKS\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  \n  /** Called when agent starts a session */\n  onSessionStart?(sessionId: string, identifiers: LayerIdentifiers): Promise<void>;\n  \n  /** Called when agent ends a session */\n  onSessionEnd?(sessionId: string): Promise<void>;\n  \n  /** Called when agent receives a message */\n  onMessage?(message: AgentMessage): Promise<void>;\n  \n  /** Called when agent uses a tool */\n  onToolUse?(toolName: string, input: unknown, output: unknown): Promise<void>;\n}\n\ninterface EcosystemConfig {\n  /** Ecosystem-specific configuration */\n  [key: string]: unknown;\n}\n\ninterface EcosystemTool {\n  /** Tool name */\n  name: string;\n  \n  /** Tool description */\n  description: string;\n  \n  /** Input schema (JSON Schema) */\n  inputSchema: object;\n  \n  /** The tool function */\n  execute: (input: unknown) => Promise<unknown>;\n}\n\ninterface SessionContext {\n  /** Memories to inject */\n  memories: MemoryEntry[];\n  \n  /** Active constraints */\n  constraints: Constraint[];\n  \n  /** System prompt additions */\n  systemPromptAdditions?: string;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"ecosystem-adapter-examples",children:"Ecosystem Adapter Examples"}),"\n",(0,i.jsx)(n.h4,{id:"langchain-adapter",children:"LangChain Adapter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { DynamicStructuredTool } from '@langchain/core/tools';\nimport { z } from 'zod';\n\nclass LangChainEcosystemAdapter implements EcosystemAdapter {\n  readonly id = 'langchain';\n  readonly name = 'LangChain';\n  readonly version = '1.0.0';\n  readonly ecosystemCompatibility = '>=0.1.0';\n  readonly coreCompatibility = '>=0.1.0';\n  \n  private core: MemoryKnowledgeCore | null = null;\n  \n  async initialize(core: MemoryKnowledgeCore, config: EcosystemConfig): Promise<void> {\n    this.core = core;\n  }\n  \n  async shutdown(): Promise<void> {\n    this.core = null;\n  }\n  \n  getMemoryTools(): EcosystemTool[] {\n    return [\n      this.createMemoryAddTool(),\n      this.createMemorySearchTool()\n    ];\n  }\n  \n  private createMemoryAddTool(): EcosystemTool {\n    const tool = new DynamicStructuredTool({\n      name: 'memory_add',\n      description: 'Store a new memory for future reference',\n      schema: z.object({\n        content: z.string().describe('The content to remember'),\n        layer: z.enum(['agent', 'user', 'session', 'project', 'team', 'org', 'company'])\n          .optional()\n          .default('user')\n          .describe('Memory scope'),\n        tags: z.array(z.string()).optional().describe('Tags for categorization')\n      }),\n      func: async (input) => {\n        const result = await this.core!.memory.add({\n          content: input.content,\n          layer: input.layer,\n          identifiers: this.getCurrentIdentifiers(),\n          metadata: { tags: input.tags }\n        });\n        return `Memory stored with ID: ${result.memory.id}`;\n      }\n    });\n    \n    return {\n      name: tool.name,\n      description: tool.description,\n      inputSchema: tool.schema,\n      execute: tool.func\n    };\n  }\n  \n  private createMemorySearchTool(): EcosystemTool {\n    const tool = new DynamicStructuredTool({\n      name: 'memory_search',\n      description: 'Search memories for relevant information',\n      schema: z.object({\n        query: z.string().describe('Search query'),\n        layers: z.array(z.enum(['agent', 'user', 'session', 'project', 'team', 'org', 'company']))\n          .optional()\n          .describe('Layers to search'),\n        limit: z.number().optional().default(5).describe('Maximum results')\n      }),\n      func: async (input) => {\n        const result = await this.core!.memory.search({\n          query: input.query,\n          layers: input.layers,\n          identifiers: this.getCurrentIdentifiers(),\n          limit: input.limit\n        });\n        \n        return result.results\n          .map(r => `[${r.layer}] ${r.memory.content}`)\n          .join('\\n\\n');\n      }\n    });\n    \n    return {\n      name: tool.name,\n      description: tool.description,\n      inputSchema: tool.schema,\n      execute: tool.func\n    };\n  }\n  \n  getKnowledgeTools(): EcosystemTool[] {\n    return [\n      this.createKnowledgeQueryTool(),\n      this.createKnowledgeCheckTool()\n    ];\n  }\n  \n  async getSessionContext(identifiers: LayerIdentifiers): Promise<SessionContext> {\n    // Fetch relevant memories\n    const memories = await this.core!.memory.search({\n      query: 'session context user preferences project conventions',\n      identifiers,\n      limit: 10\n    });\n    \n    // Fetch active constraints\n    const knowledge = await this.core!.knowledge.query({\n      status: 'accepted',\n      identifiers\n    });\n    \n    const constraints = knowledge.items\n      .flatMap(item => item.constraints ?? [])\n      .filter(c => c.severity === 'block' || c.severity === 'warn');\n    \n    return {\n      memories: memories.results.map(r => r.memory),\n      constraints,\n      systemPromptAdditions: this.buildSystemPrompt(constraints)\n    };\n  }\n  \n  private buildSystemPrompt(constraints: Constraint[]): string {\n    if (constraints.length === 0) return '';\n    \n    const lines = ['## Active Constraints', ''];\n    for (const c of constraints) {\n      lines.push(`- [${c.severity.toUpperCase()}] ${c.message ?? formatConstraint(c)}`);\n    }\n    return lines.join('\\n');\n  }\n  \n  // Hook implementations\n  async onSessionStart(sessionId: string, identifiers: LayerIdentifiers): Promise<void> {\n    // Trigger incremental sync\n    await this.core!.sync.incrementalSync({ identifiers });\n  }\n  \n  async onToolUse(toolName: string, input: unknown, output: unknown): Promise<void> {\n    // Optionally log tool usage to memory\n    if (this.shouldLogToolUsage(toolName)) {\n      await this.core!.memory.add({\n        content: `Used tool ${toolName} with result: ${JSON.stringify(output).substring(0, 200)}`,\n        layer: 'session',\n        identifiers: this.getCurrentIdentifiers(),\n        metadata: {\n          source: { type: 'tool_result', reference: toolName }\n        }\n      });\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"opencode-adapter",children:"OpenCode Adapter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class OpenCodeEcosystemAdapter implements EcosystemAdapter {\n  readonly id = 'opencode';\n  readonly name = 'OpenCode';\n  readonly version = '1.0.0';\n  readonly ecosystemCompatibility = '>=1.0.150';\n  readonly coreCompatibility = '>=0.1.0';\n  \n  private core: MemoryKnowledgeCore | null = null;\n  \n  async initialize(core: MemoryKnowledgeCore, config: EcosystemConfig): Promise<void> {\n    this.core = core;\n  }\n  \n  getMemoryTools(): EcosystemTool[] {\n    return [\n      {\n        name: 'memory_add',\n        description: 'Store information in long-term memory for future sessions',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            content: { type: 'string', description: 'What to remember' },\n            layer: { \n              type: 'string', \n              enum: ['agent', 'user', 'session', 'project', 'team', 'org', 'company'],\n              default: 'user'\n            },\n            tags: { type: 'array', items: { type: 'string' } }\n          },\n          required: ['content']\n        },\n        execute: async (input: any) => {\n          return this.core!.memory.add({\n            content: input.content,\n            layer: input.layer ?? 'user',\n            identifiers: this.getCurrentIdentifiers(),\n            metadata: { tags: input.tags }\n          });\n        }\n      },\n      {\n        name: 'memory_search',\n        description: 'Search memories for relevant past information',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: { type: 'string', description: 'Search query' },\n            layers: { \n              type: 'array', \n              items: { type: 'string' }\n            },\n            limit: { type: 'number', default: 10 }\n          },\n          required: ['query']\n        },\n        execute: async (input: any) => {\n          return this.core!.memory.search({\n            query: input.query,\n            layers: input.layers,\n            identifiers: this.getCurrentIdentifiers(),\n            limit: input.limit ?? 10\n          });\n        }\n      }\n    ];\n  }\n  \n  getKnowledgeTools(): EcosystemTool[] {\n    return [\n      {\n        name: 'knowledge_query',\n        description: 'Search organizational knowledge (ADRs, policies, patterns)',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: { type: 'string' },\n            type: { type: 'string', enum: ['adr', 'policy', 'pattern', 'spec'] },\n            tags: { type: 'array', items: { type: 'string' } }\n          }\n        },\n        execute: async (input: any) => {\n          return this.core!.knowledge.query({\n            query: input.query,\n            type: input.type,\n            tags: input.tags,\n            identifiers: this.getCurrentIdentifiers()\n          });\n        }\n      },\n      {\n        name: 'knowledge_check',\n        description: 'Check if current action violates any constraints',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            files: {\n              type: 'array',\n              items: {\n                type: 'object',\n                properties: {\n                  path: { type: 'string' },\n                  content: { type: 'string' }\n                }\n              }\n            },\n            dependencies: {\n              type: 'array',\n              items: {\n                type: 'object',\n                properties: {\n                  name: { type: 'string' },\n                  version: { type: 'string' }\n                }\n              }\n            }\n          }\n        },\n        execute: async (input: any) => {\n          return this.core!.knowledge.checkConstraints({\n            files: input.files,\n            dependencies: input.dependencies,\n            identifiers: this.getCurrentIdentifiers()\n          });\n        }\n      }\n    ];\n  }\n  \n  async getSessionContext(identifiers: LayerIdentifiers): Promise<SessionContext> {\n    // OpenCode-specific context enrichment\n    const memories = await this.core!.memory.search({\n      query: 'coding preferences project patterns user style',\n      identifiers,\n      limit: 15,\n      layers: ['agent', 'user', 'project', 'team', 'org', 'company']\n    });\n    \n    const knowledge = await this.core!.knowledge.query({\n      status: 'accepted',\n      identifiers,\n      limit: 20\n    });\n    \n    const constraints = knowledge.items\n      .flatMap(item => item.constraints ?? []);\n    \n    return {\n      memories: memories.results.map(r => r.memory),\n      constraints,\n      systemPromptAdditions: this.buildOpenCodeSystemPrompt(memories.results, constraints)\n    };\n  }\n  \n  private buildOpenCodeSystemPrompt(\n    memories: MemorySearchResult[], \n    constraints: Constraint[]\n  ): string {\n    const sections: string[] = [];\n    \n    // Memory context\n    if (memories.length > 0) {\n      sections.push('## Relevant Context from Memory\\n');\n      for (const m of memories.slice(0, 5)) {\n        sections.push(`- ${m.memory.content}`);\n      }\n    }\n    \n    // Blocking constraints\n    const blocking = constraints.filter(c => c.severity === 'block');\n    if (blocking.length > 0) {\n      sections.push('\\n## BLOCKING Constraints (Must Follow)\\n');\n      for (const c of blocking) {\n        sections.push(`- ${c.message ?? `${c.operator}: ${c.pattern}`}`);\n      }\n    }\n    \n    // Warning constraints\n    const warnings = constraints.filter(c => c.severity === 'warn');\n    if (warnings.length > 0) {\n      sections.push('\\n## Warnings (Should Follow)\\n');\n      for (const c of warnings) {\n        sections.push(`- ${c.message ?? `${c.operator}: ${c.pattern}`}`);\n      }\n    }\n    \n    return sections.join('\\n');\n  }\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"adapter-registration",children:"Adapter Registration"}),"\n",(0,i.jsx)(n.h3,{id:"registry-interface",children:"Registry Interface"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface AdapterRegistry {\n  // Provider adapters\n  registerProvider(adapter: MemoryProviderAdapter): void;\n  getProvider(id: string): MemoryProviderAdapter | undefined;\n  listProviders(): MemoryProviderAdapter[];\n  \n  // Ecosystem adapters\n  registerEcosystem(adapter: EcosystemAdapter): void;\n  getEcosystem(id: string): EcosystemAdapter | undefined;\n  listEcosystems(): EcosystemAdapter[];\n  \n  // Auto-discovery\n  discoverAdapters(searchPaths?: string[]): Promise<void>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"registration-example",children:"Registration Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Manual registration\nconst registry = new AdapterRegistry();\n\nregistry.registerProvider(new Mem0ProviderAdapter());\nregistry.registerProvider(new ChromaProviderAdapter());\nregistry.registerProvider(new LettaProviderAdapter());\n\nregistry.registerEcosystem(new LangChainEcosystemAdapter());\nregistry.registerEcosystem(new OpenCodeEcosystemAdapter());\n\n// Auto-discovery\nawait registry.discoverAdapters([\n  './node_modules/@memory-knowledge/adapter-*',\n  './custom-adapters'\n]);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"adapter-package-convention",children:"Adapter Package Convention"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'@memory-knowledge/adapter-mem0/\n\u251c\u2500\u2500 package.json\n\u2502   {\n\u2502     "name": "@memory-knowledge/adapter-mem0",\n\u2502     "memory-knowledge": {\n\u2502       "type": "provider",\n\u2502       "id": "mem0"\n\u2502     }\n\u2502   }\n\u251c\u2500\u2500 index.ts\n\u2514\u2500\u2500 README.md\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"adapter-lifecycle",children:"Adapter Lifecycle"}),"\n",(0,i.jsx)(n.h3,{id:"lifecycle-diagram",children:"Lifecycle Diagram"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                                  \u2502\n\u2502     UNINITIALIZED                                               \u2502\n\u2502           \u2502                                                      \u2502\n\u2502           \u2502 register()                                          \u2502\n\u2502           \u25bc                                                      \u2502\n\u2502     REGISTERED                                                   \u2502\n\u2502           \u2502                                                      \u2502\n\u2502           \u2502 initialize(config)                                  \u2502\n\u2502           \u25bc                                                      \u2502\n\u2502     INITIALIZING                                                 \u2502\n\u2502           \u2502                                                      \u2502\n\u2502           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba ERROR (on failure)                \u2502\n\u2502           \u2502                      \u2502                               \u2502\n\u2502           \u2502                      \u2502 retry()                      \u2502\n\u2502           \u2502                      \u25bc                               \u2502\n\u2502           \u2502                   INITIALIZING                       \u2502\n\u2502           \u2502                                                      \u2502\n\u2502           \u2502 (on success)                                        \u2502\n\u2502           \u25bc                                                      \u2502\n\u2502     READY \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                 \u2502\n\u2502           \u2502                    \u2502                                 \u2502\n\u2502           \u2502 healthCheck()      \u2502 reconnect()                    \u2502\n\u2502           \u2502                    \u2502                                 \u2502\n\u2502           \u25bc                    \u2502                                 \u2502\n\u2502     HEALTHY / DEGRADED \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502\n\u2502           \u2502                                                      \u2502\n\u2502           \u2502 shutdown()                                          \u2502\n\u2502           \u25bc                                                      \u2502\n\u2502     SHUTTING_DOWN                                                \u2502\n\u2502           \u2502                                                      \u2502\n\u2502           \u25bc                                                      \u2502\n\u2502     SHUTDOWN                                                     \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(n.h3,{id:"state-management",children:"State Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"type AdapterState = \n  | 'uninitialized'\n  | 'registered'\n  | 'initializing'\n  | 'ready'\n  | 'healthy'\n  | 'degraded'\n  | 'error'\n  | 'shutting_down'\n  | 'shutdown';\n\ninterface AdapterStateManager {\n  getState(): AdapterState;\n  \n  onStateChange(callback: (state: AdapterState) => void): void;\n  \n  waitForReady(timeoutMs?: number): Promise<void>;\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"testing-adapters",children:"Testing Adapters"}),"\n",(0,i.jsx)(n.h3,{id:"test-interface",children:"Test Interface"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"/**\n * Compliance test suite for adapters.\n */\ninterface AdapterTestSuite {\n  /** Run all compliance tests */\n  runAll(): Promise<TestResults>;\n  \n  /** Test basic CRUD operations */\n  testCrud(): Promise<TestResult>;\n  \n  /** Test search functionality */\n  testSearch(): Promise<TestResult>;\n  \n  /** Test layer isolation */\n  testLayerIsolation(): Promise<TestResult>;\n  \n  /** Test error handling */\n  testErrorHandling(): Promise<TestResult>;\n  \n  /** Test concurrent operations */\n  testConcurrency(): Promise<TestResult>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"mock-adapter-for-testing",children:"Mock Adapter for Testing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"/**\n * In-memory mock adapter for testing.\n */\nclass MockProviderAdapter implements MemoryProviderAdapter {\n  readonly id = 'mock';\n  readonly name = 'Mock (In-Memory)';\n  readonly version = '1.0.0';\n  readonly coreCompatibility = '*';\n  \n  readonly capabilities: ProviderCapabilities = {\n    vectorSearch: true,\n    metadataFiltering: true,\n    bulkOperations: true,\n    dataPortability: true,\n    realTimeUpdates: true,\n    maxContentLength: Infinity,\n    maxMetadataSize: Infinity,\n    embeddingDimensions: 384,\n    distanceMetrics: ['cosine']\n  };\n  \n  private memories: Map<string, MemoryEntry> = new Map();\n  \n  async initialize(): Promise<void> {}\n  \n  async shutdown(): Promise<void> {\n    this.memories.clear();\n  }\n  \n  async healthCheck(): Promise<HealthCheckResult> {\n    return { status: 'healthy', latencyMs: 0 };\n  }\n  \n  async add(input: AddMemoryInput): Promise<AddMemoryOutput> {\n    const id = crypto.randomUUID();\n    const memory: MemoryEntry = {\n      id,\n      content: input.content,\n      layer: input.layer,\n      identifiers: input.identifiers,\n      metadata: input.metadata ?? {},\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      embedding: await this.generateEmbedding(input.content)\n    };\n    \n    this.memories.set(id, memory);\n    \n    return { memory, embeddingGenerated: true };\n  }\n  \n  async search(input: SearchMemoryInput): Promise<SearchMemoryOutput> {\n    const queryEmbedding = await this.generateEmbedding(input.query);\n    const results: MemorySearchResult[] = [];\n    \n    for (const memory of this.memories.values()) {\n      if (!input.layers?.includes(memory.layer)) continue;\n      \n      const score = this.cosineSimilarity(queryEmbedding, memory.embedding!);\n      if (score >= (input.threshold ?? 0.7)) {\n        results.push({ memory, score, layer: memory.layer });\n      }\n    }\n    \n    return {\n      results: results.sort((a, b) => b.score - a.score).slice(0, input.limit ?? 10),\n      totalCount: results.length,\n      searchedLayers: input.layers ?? []\n    };\n  }\n  \n  async generateEmbedding(content: string): Promise<number[]> {\n    // Simple hash-based mock embedding\n    const embedding = new Array(384).fill(0);\n    for (let i = 0; i < content.length; i++) {\n      embedding[i % 384] += content.charCodeAt(i) / 1000;\n    }\n    return this.normalize(embedding);\n  }\n  \n  private cosineSimilarity(a: number[], b: number[]): number {\n    let dot = 0, normA = 0, normB = 0;\n    for (let i = 0; i < a.length; i++) {\n      dot += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n    return dot / (Math.sqrt(normA) * Math.sqrt(normB));\n  }\n  \n  private normalize(v: number[]): number[] {\n    const norm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));\n    return v.map(x => x / norm);\n  }\n  \n  // ... other methods\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"reference-implementations",children:"Reference Implementations"}),"\n",(0,i.jsx)(n.h3,{id:"provider-adapters-1",children:"Provider Adapters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Provider"}),(0,i.jsx)(n.th,{children:"Package"}),(0,i.jsx)(n.th,{children:"Status"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Mem0"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-mem0"})}),(0,i.jsx)(n.td,{children:"Reference"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Letta"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-letta"})}),(0,i.jsx)(n.td,{children:"Planned"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Chroma"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-chroma"})}),(0,i.jsx)(n.td,{children:"Planned"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Pinecone"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-pinecone"})}),(0,i.jsx)(n.td,{children:"Planned"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Qdrant"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-qdrant"})}),(0,i.jsx)(n.td,{children:"Planned"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"PostgreSQL"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-postgres"})}),(0,i.jsx)(n.td,{children:"Planned"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"ecosystem-adapters-1",children:"Ecosystem Adapters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Ecosystem"}),(0,i.jsx)(n.th,{children:"Package"}),(0,i.jsx)(n.th,{children:"Status"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"OpenCode"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-opencode"})}),(0,i.jsx)(n.td,{children:"Reference"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"LangChain"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-langchain"})}),(0,i.jsx)(n.td,{children:"Planned"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"AutoGen"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-autogen"})}),(0,i.jsx)(n.td,{children:"Planned"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"CrewAI"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@memory-knowledge/adapter-crewai"})}),(0,i.jsx)(n.td,{children:"Planned"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next"}),": ",(0,i.jsx)(n.a,{href:"/aeterna/docs/specs/tool-interface",children:"06-tool-interface.md"})," - Tool Interface Specification"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);