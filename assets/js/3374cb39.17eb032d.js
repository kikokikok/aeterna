"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6783],{4804(e,n,r){r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"helm/security","title":"Security Best Practices","description":"Pod Security Standards","source":"@site/docs/helm/security.md","sourceDirName":"helm","slug":"/helm/security","permalink":"/aeterna/docs/helm/security","draft":false,"unlisted":false,"editUrl":"https://github.com/kikokikok/aeterna/tree/main/website/docs/helm/security.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Production Deployment Checklist","permalink":"/aeterna/docs/helm/production-checklist"},"next":{"title":"External Secrets Operator Integration","permalink":"/aeterna/docs/helm/external-secrets"}}');var t=r(4848),i=r(8453);const c={},l="Security Best Practices",a={},d=[{value:"Pod Security Standards",id:"pod-security-standards",level:2},{value:"Network Policies",id:"network-policies",level:2},{value:"Image Pull Secrets",id:"image-pull-secrets",level:2},{value:"Secret Management",id:"secret-management",level:2},{value:"RBAC",id:"rbac",level:2},{value:"TLS",id:"tls",level:2},{value:"Supply Chain Security",id:"supply-chain-security",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"security-best-practices",children:"Security Best Practices"})}),"\n",(0,t.jsx)(n.h2,{id:"pod-security-standards",children:"Pod Security Standards"}),"\n",(0,t.jsxs)(n.p,{children:["Aeterna enforces the ",(0,t.jsx)(n.strong,{children:"restricted"})," Pod Security Standard profile on all pods:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"runAsNonRoot: true"})," (UID 1000)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"readOnlyRootFilesystem: true"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"allowPrivilegeEscalation: false"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"capabilities.drop: [ALL]"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"seccompProfile.type: RuntimeDefault"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These settings are applied to both the main Aeterna deployment and all auxiliary jobs (migration, backup, backup-verify)."}),"\n",(0,t.jsx)(n.p,{children:"To enforce at the namespace level:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl label namespace aeterna \\\n  pod-security.kubernetes.io/enforce=restricted \\\n  pod-security.kubernetes.io/audit=restricted \\\n  pod-security.kubernetes.io/warn=restricted\n"})}),"\n",(0,t.jsx)(n.h2,{id:"network-policies",children:"Network Policies"}),"\n",(0,t.jsx)(n.p,{children:"Enable network policies to restrict traffic:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"networkPolicy:\n  enabled: true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When enabled, Aeterna creates ",(0,t.jsx)(n.code,{children:"NetworkPolicy"})," resources for:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Component"}),(0,t.jsx)(n.th,{children:"Ingress"}),(0,t.jsx)(n.th,{children:"Egress"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Aeterna server"}),(0,t.jsx)(n.td,{children:"Ingress controller, Prometheus"}),(0,t.jsx)(n.td,{children:"PostgreSQL, Qdrant, Redis, OPAL, DNS"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"OPAL Server"}),(0,t.jsx)(n.td,{children:"Fetcher, Cedar Agent, Aeterna"}),(0,t.jsx)(n.td,{children:"PostgreSQL, Redis, DNS, external HTTPS"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Cedar Agent"}),(0,t.jsx)(n.td,{children:"Aeterna"}),(0,t.jsx)(n.td,{children:"OPAL Server, DNS, external HTTPS"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"OPAL Fetcher"}),(0,t.jsx)(n.td,{children:"OPAL Server"}),(0,t.jsx)(n.td,{children:"OPAL Server, PostgreSQL, DNS, external HTTPS"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"All other traffic is denied by default."}),"\n",(0,t.jsx)(n.h2,{id:"image-pull-secrets",children:"Image Pull Secrets"}),"\n",(0,t.jsx)(n.p,{children:"For private registries, configure image pull secrets:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"aeterna:\n  imagePullSecrets:\n    - name: my-registry-secret\n\nglobal:\n  imagePullSecrets:\n    - name: my-registry-secret\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create the secret:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl create secret docker-registry my-registry-secret \\\n  --docker-server=ghcr.io \\\n  --docker-username=USERNAME \\\n  --docker-password=TOKEN\n"})}),"\n",(0,t.jsx)(n.h2,{id:"secret-management",children:"Secret Management"}),"\n",(0,t.jsxs)(n.p,{children:["Never store credentials in ",(0,t.jsx)(n.code,{children:"values.yaml"}),". Use one of:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Kubernetes Secrets"})," (default): Create secrets manually, reference via ",(0,t.jsx)(n.code,{children:"existingSecret"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SOPS"}),": Encrypt values files at rest. See ",(0,t.jsx)(n.a,{href:"/aeterna/docs/helm/sops-secrets",children:"sops-secrets.md"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"External Secrets Operator"}),": Sync from Vault/AWS/Azure. See ",(0,t.jsx)(n.a,{href:"/aeterna/docs/helm/external-secrets",children:"external-secrets.md"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"secrets:\n  provider: helm          # helm (default), sops, external-secrets\n"})}),"\n",(0,t.jsx)(n.h2,{id:"rbac",children:"RBAC"}),"\n",(0,t.jsxs)(n.p,{children:["Aeterna creates a ",(0,t.jsx)(n.code,{children:"ServiceAccount"}),", ",(0,t.jsx)(n.code,{children:"Role"}),", and ",(0,t.jsx)(n.code,{children:"RoleBinding"})," scoped to its namespace. The service account token is auto-mounted for in-cluster API access required by the migration job."]}),"\n",(0,t.jsx)(n.p,{children:"To use a pre-existing service account:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'aeterna:\n  serviceAccount:\n    create: false\n    name: "my-existing-sa"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"tls",children:"TLS"}),"\n",(0,t.jsx)(n.p,{children:"Enable TLS on the ingress:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"aeterna:\n  ingress:\n    enabled: true\n    className: nginx\n    annotations:\n      cert-manager.io/cluster-issuer: letsencrypt-prod\n    tls:\n      - secretName: aeterna-tls\n        hosts:\n          - aeterna.example.com\n"})}),"\n",(0,t.jsx)(n.p,{children:"For internal service-to-service TLS, configure your service mesh (Istio, Linkerd) to inject mTLS sidecars."}),"\n",(0,t.jsx)(n.h2,{id:"supply-chain-security",children:"Supply Chain Security"}),"\n",(0,t.jsx)(n.p,{children:"Aeterna container images are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Built with multi-arch support (amd64 + arm64)"}),"\n",(0,t.jsx)(n.li,{children:"Scanned with Trivy for CVEs"}),"\n",(0,t.jsx)(n.li,{children:"Signed with Cosign for provenance verification"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Verify image signatures:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'cosign verify ghcr.io/kikokikok/aeterna:latest \\\n  --certificate-identity-regexp=".*" \\\n  --certificate-oidc-issuer-regexp=".*"\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453(e,n,r){r.d(n,{R:()=>c,x:()=>l});var s=r(6540);const t={},i=s.createContext(t);function c(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);